### 贪心策略

用类似层序遍历的过程，将第 `i` 次跳跃的「起始位置」和「结束位置」找出来，用这次跳跃的情况，更新出下一次跳跃的「起始位置」和「终止位置」。这样「循环往复」，就能更新出到达 `n - 1` 位置的最小跳跃步数。

#### 1. 策略核心

-   **核心思想**：每次跳跃选择当前范围内能到达的最远位置，通过分层扩展覆盖区间，确保最少跳跃次数。
-   **关键操作**：
    -   维护当前跳跃的区间 `[left, right]`，表示当前跳跃步数下可达的位置范围。
    -   遍历当前区间内的所有位置，计算下一步能到达的最远位置 `maxpos`。
    -   更新下一跳跃的区间为 `[right+1, maxpos]`，跳跃次数加一。
    -   当区间覆盖终点时，返回当前跳跃次数。

#### 2. 策略步骤

1.  **初始化**：`left=0`, `right=0`（起始位置），`ret=0`（跳跃次数）。
2.  **循环处理**：
    -   若当前区间 `[left, right]` 已覆盖终点，返回 `ret`。
    -   遍历当前区间内的所有位置，更新 `maxpos` 为能跳到的最远位置。
    -   更新下一区间为 `[right+1, maxpos]`，跳跃次数 `ret++`。
3.  **终止条件**：题目保证有解，最终必能覆盖终点。

---

### 正确性证明

#### 1. 贪心选择性质

-   每一步选择当前区间内能到达的最远位置（`maxpos`），确保覆盖尽可能多的后续位置。
-   例如，若当前区间为 `[a, b]`，选择 `maxpos` 后，下一区间为 `[b+1, maxpos]`。此操作能覆盖所有可能的跳跃路径中最远的位置，从而减少后续需要的跳跃次数。

#### 2. 最优子结构

-   假设存在更优路径，跳跃次数更少，则必然在某一步未选择最远可达位置，导致后续需要额外跳跃。与贪心策略矛盾，故贪心策略最优。

#### 3. 示例验证

-   **输入**：`[2,3,1,1,4]`
    -   初始区间 `[0,0]`，`maxpos=2` → 下一区间 `[1,2]`，`ret=1`。
    -   遍历 `[1,2]`，`maxpos=4` → 下一区间 `[3,4]`，`ret=2`。
    -   `right >=4`，返回 `2`。

#### 4. 关键点解释

1.  **区间维护**：
    -   `left` 和 `right` 动态表示当前跳跃步数下可到达的位置范围。
    -   每次更新区间时，`left` 设为当前右边界+1，`right` 设为 `maxpos`，确保不重复处理已覆盖的位置。
2.  **跳跃次数的计算**：
    -   每次区间更新代表完成一次跳跃，`ret` 严格递增。
3.  **时间复杂度**：O(n)，每个位置最多被访问一次。

---

### 动态规划算法原理：

1.  **状态表示**：

    -   定义 `dp[i]` 表示跳到下标 `i` 所需要的最少跳跃次数。

2.  **状态转移方程**：

    -   从位置 `i` 出发，最多能跳 `nums[i]` 步。对于跳跃范围内的每个位置 `i + j`（`1 ≤ j ≤ nums[i]`），状态转移方程为：

    $$
    dp [i+j] = min(dp [i+j], dp [i]+1)
    $$

    -   意思是，跳到 `i + j` 的最小跳跃次数要么保持不变，要么从 `i` 跳跃一次过去。

3.  **初始化**：

    -   起点 `dp[0] = 0`，表示站在起点时不需要跳跃。
    -   其他位置初始化为 `INT_MAX`，表示尚未到达。

4.  **填表顺序**：

    -   从左到右遍历 `nums` 数组，每次更新从当前点能跳到的所有位置的 `dp` 值。

5.  **返回值**：

    -   `dp[n - 1]` 即跳到最后位置的最小跳跃次数。

6.   时间复杂度：
     -   动态规划解法：`O(n^2)`。外层遍历 `n` 次，内层遍历最多 `nums[i]` 次。