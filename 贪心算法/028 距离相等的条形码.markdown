### 贪心策略

#### 1. 问题背景

给定一个条形码数组 `barcodes`，要求重新排列这些条形码，使得相邻的条形码不相同。题目保证存在至少一种有效解。

![image-20250315175612183](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250315175612346.png)

---

#### 2. 贪心思想的核心

1. **优先处理出现次数最多的元素**：
   - 统计所有条形码的出现次数，找到出现次数最多的条形码 `maxval`。
   - 将 `maxval` 优先填入结果数组的偶数索引位置（如 0、2、4…），确保其不会相邻。
   - 因为 `maxval` 的出现次数最多，若不优先处理，可能会导致其难以分散放置。

2. **剩余元素填入奇数索引**：
   - 剩下的元素按任意顺序依次填入奇数索引位置（如 1、3、5…），同样间隔放置。
   - 若奇数索引填满后，从第一个奇数位置（索引 1）重新开始填入，确保不覆盖已填位置。

#### 3. 代码实现步骤

1. **统计次数与确定最大值**：
   - 使用哈希表 `hash` 统计每个条形码的出现次数。
   - 找到出现次数最多的条形码 `maxval` 及其次数 `maxcount`。

2. **填充最大值到偶数位置**：
   - 初始化结果数组 `ret`，从索引 0 开始，每隔两位填入 `maxval`，直到用完所有 `maxval`。
   - 例如，若 `maxcount = 3`，则填入 `ret[0], ret[2], ret[4]`。

3. **处理剩余元素**：
   - 删除 `maxval` 的记录，遍历剩余元素。
   - 对每个剩余元素 `x`，按其出现次数 `y`，从当前索引开始每隔两位填入 `x`：
     - 若索引超出数组长度，重置索引为 1（奇数位置的起始点）。
     - 例如，若当前索引为 6（超过数组长度），则填入索引 1，接着是 3、5 等。

---

#### 4. 贪心正确性证明

该贪心策略通过 **高频隔离** 和 **间隔填充**，结合 **鸽巢原理** 对剩余元素频率的约束，确保了排列的合法性。其正确性依赖于：

1.  高频值的索引隔离
2.  剩余元素的频率不超过剩余位置的一半（鸽巢原理保证）

由题意保证输入有解，故必有：出现次数最多的那个数字一定不超过 $(n+1)/2$ 次，只能小于等于 $(n+1)/2$ 次（鸠巢原理）。也可举例证明（反证法），无法找出反例，则此贪心策略正确。

#### 5. 关键点分析

- **为什么优先填偶数索引？**
  - 出现次数最多的元素需要尽可能分散，偶数索引（如 0、2、4）确保它们之间至少间隔一个位置。
- **如何保证剩余元素不相邻？**
  - 剩余元素的出现次数均小于等于 `maxcount`，填入奇数索引时，间隔放置可避免相邻重复。
- **索引重置的逻辑**：
  - 若索引超出数组长度，重置为 1（奇数起始点），确保继续填入奇数位置。
