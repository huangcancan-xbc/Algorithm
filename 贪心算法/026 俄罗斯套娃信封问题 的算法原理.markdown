### 贪心策略

#### 1. 问题背景

给定一组信封的宽度和高度 `[w, h]`，当一个信封的宽度和高度均严格大于另一个信封时，可以嵌套。求最多能嵌套的信封数量。

本题的核心思想是 **先对信封排序**，然后 **使用贪心 + 二分查找** 来求解 **最长递增子序列（LIS）**。

![image-20250315154817235](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250315154817360.png)

---

#### 2. 解题思路

##### 1. 重写排序规则

- **排序规则**：  
  1. **按宽度（w）升序排序**，保证较小的宽度在前。
  2. **如果宽度相同，则按高度（h）降序排序**，这样可以确保相同宽度的信封不会影响 LIS 计算。
- **为什么要这样排序？**
    - 确保宽度递增，避免同一宽度的信封被多次选中。  
    - 同一宽度的信封按高度降序排列后，后续处理时只需关注高度递增，避免宽度重复。**因为同宽度下高度降序排序后，相同宽度的信封不会嵌套**（否则可能会错误地计入 LIS）。
    - 当我们处理高度序列时，可以直接在排序后的序列中寻找 **最长递增子序列（LIS）**，不需要考虑宽度的问题。


**排序示例**：

输入 `[[5,4], [6,7], [2,3], [6,4]]`，排序后：`[[2,3], [5,4], [6,7], [6,4]]`  

- 宽度 `6` 的两个信封，按高度降序排列为 `[6,7]` 和 `[6,4]`。
- 宽度 **升序** 排序保证后面的信封一定不会比前面的小。
- 相同宽度 **降序** 排序保证相同宽度的不会影响 LIS 计算。

##### 2. 转化为最长递增子序列（LIS）问题

**问题转换**：排序后，只需在高度序列中寻找最长严格递增子序列的长度。例如，排序后的高度序列为 `[3,4,7,4]`，最长递增子序列为 `[3,4,7]`，长度为 `3`。

##### 3. 贪心 + 二分查找

排序后，我们可以忽略宽度 **w**，只考虑 **高度 h**，然后在高度序列上 **寻找最长递增子序列（LIS）**。

- **维护数组 `ret`**：`ret[i]` 表示长度为 `i+1` 的递增子序列的最小末尾值。
- **遍历高度**：  
  - 若当前高度 `h` > `ret.back()`，直接加入 `ret`。  
  - 否则，通过二分查找在 `ret` 中找到第一个 `≥h` 的位置并替换，保持 `ret` 的单调性（用 **二分查找** 找到 `ret` 中 **第一个大于等于 `b` 的位置**，并替换它（相当于维护更小的增长路径））。

1.  **二分查找的作用**：快速定位当前高度 `h` 在 `ret` 中的插入位置，保证 `ret` 数组始终是当前最优的递增序列。
2.  **二分查找的目的**： **在 ret 数组中找到第一个大于等于当前 b 的位置**，然后用 `b` 替换它。

---

#### 3. 正确性分析

##### 1. 排序规则的正确性

- **宽度升序**：确保后续信封的宽度一定 ≥ 当前宽度。  
- **同宽度高度降序**：同一宽度的信封只能选一个（高度最大的），避免多次选择同一宽度。

##### 2. LIS 的正确性

- 排序后，问题等价于在高度序列中找最长递增子序列。  
- 由于宽度已排序，高度递增保证了嵌套关系的严格性。

#### 4. 关键点解释

1. **排序规则**：  
   - 宽度升序确保嵌套宽度严格递增。  
   - 同宽度高度降序避免选择多个同宽度信封。

2. **贪心策略**：  
   - 维护 `ret` 数组保存最小末尾值，保证后续能插入更多元素。  
   - 替换策略（用更小的值替代）使得 `ret` 更可能延长。

3. **时间复杂度**：  
   - 排序 `O(n log n)`，遍历 + 二分 `O(n log n)`，总复杂度 `O(n log n)`。

---

#### 5. 完整流程示例

以 `envelopes = {{5,4}, {6,4}, {6,7}, {2,3}, {7,8}, {7,5}, {6,6}, {3,9}}` 为例：

##### 第一步：排序

按照 **重写排序规则**：

```cpp
{{2,3}, {3,9}, {5,4}, {6,7}, {6,6}, {6,4}, {7,8}, {7,5}}
```

##### 第二步：贪心 + 二分查找

现在我们只看高度（h），转换为求 **最长递增子序列（LIS）** 的问题：

```cpp
{3, 9, 4, 7, 6, 4, 8, 5}
```

用 `ret` 来维护 **当前的 LIS**：

1.  遍历高度序列。
2.  **如果当前高度比 `ret` 的最后一个元素大**，直接 `push_back`。
3.  **否则，使用二分查找找到第一个大于等于当前高度的位置**，用当前高度替换它（保持最优增长路径）。

##### 第三步：逐步分析 `ret` 的变化

| 当前高度 | `ret` 变化     | 解释                                                         |
| -------- | -------------- | ------------------------------------------------------------ |
| `3`      | `[3]`          | 初始值，直接加入                                             |
| `9`      | `[3, 9]`       | `9 > 3`，直接加入                                            |
| `4`      | `[3, 4]`       | `4 < 9`，用二分查找第一个 >= `4` 的位置（1），替换（优化后续增长） |
| `7`      | `[3, 4, 7]`    | `7 > 4`，直接加入                                            |
| `6`      | `[3, 4, 6]`    | `6 < 7`，用二分查找第一个 >= `6` 的位置（2），替换           |
| `4`      | `[3, 4, 6]`    | `4 = 4`，用二分查找找到第一个 >= `4` 的位置（1），替换       |
| `8`      | `[3, 4, 6, 8]` | `8 > 6`，直接加入                                            |
| `5`      | `[3, 4, 5, 8]` | `5 < 8`，用二分查找第一个 >= `5` 的位置（2），替换           |

最终的 `ret` 是：`[3, 4, 5, 8]`，对应的最长递增子序列长度为 **4**。