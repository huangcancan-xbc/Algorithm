### 贪心策略

![image-20250312122404392](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250312122404530.png)



### 贪心思想解析

1. **问题特征**：
    - 排序的依赖关系仅由身高决定。
    - 需要保留原始数据，仅生成排序后的姓名列表。

2. **贪心策略**：
    - **局部最优选择**：每一步选择当前未处理的最高身高对应的索引，将其放置到结果中的正确位置。
    - **全局最优结果**：所有索引按身高降序排列后，遍历索引数组即可得到全局有序的姓名列表。

3. **关键操作**：
    - 通过索引数组记录原始位置，仅对索引排序，不修改原数据。
    - 比较时依赖原数组 `heights` 的值，但操作对象是轻量级的索引（整数），效率更高。

#### 为何是贪心？

- **局部最优性**：每次比较两个索引时，选择身高更高的索引，确保当前局部的最优顺序。
- **无后效性**：一旦索引顺序确定，后续操作仅需按顺序提取结果，无需回溯。

#### 实例演示

以输入为例：

- `names = ["Mary", "John", "Emma"]`
- `heights = [180, 165, 170]`

1. **初始化索引数组**：

    ```cpp
    index = [0, 1, 2]
    ```

2. **按身高排序索引**：

    - 比较 `heights[0]=180`, `heights[1]=165`, `heights[2]=170`。
    - 排序后索引数组变为 `index = [0, 2, 1]`（对应身高 `180, 170, 165`）。

3. **提取姓名**：

    ```cpp
    ret = [names[0], names[2], names[1]] = ["Mary", "Emma", "John"]
    ```
