### 贪心策略

#### 1. 问题背景

给定一个区间集合，要求合并所有重叠的区间。例如，输入 `[[1,3],[2,6],[8,10],[15,18]]`，合并后输出 `[[1,6],[8,10],[15,18]]`。

![image-20250313211441042](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250313211441342.png)

---

#### 2. 贪心策略分析

##### 1. 策略核心

- **核心思想**：将所有区间按左端点从小到大排序，然后依次合并相邻的区间。
- **合并条件**：若当前区间的左端点 ≤ 已合并区间的右端点，则合并（取最大右端点）；否则视为新区间。

##### 2. 策略步骤

1. **排序**：按区间的左端点升序排序。
2. **初始化**：取第一个区间作为当前合并区间 `[left, right]`。
3. **遍历合并**：
   - 若下一区间的左端点 `a` ≤ `right`，则合并（`right = max(right, b)`）。
   - 否则，将当前合并区间加入结果，并更新 `left` 和 `right` 为新区间。
4. **终止处理**：将最后一个合并区间加入结果。

---

#### 3. 确性证明

##### 1. 排序的必要性

- 按左端点排序后，区间按左端点从小到大排列。这使得：
  - 若两个区间可合并，它们一定是连续的（排序后中间不会插入其他区间）。
  - 例如，若排序后为 `A, B, C`，且 `A` 和 `C` 可合并，则 `B` 的左端点必在 `A` 的范围内，`B` 会被提前合并到 `A` 中。

##### 2. 合并操作的完备性

- **数学归纳法**：假设前 `k` 个区间已合并为最优结果，处理第 `k+1` 个区间时：
  - 若可合并，则合并后仍保持最优（取最大右端点，覆盖后续可能的重叠）。
  - 若不可合并，则后续区间的左端点更大，无需回溯。

##### 3. 示例验证

- **输入**：`[[1,3],[2,6],[8,10],[15,18]]`  
  - 排序后顺序不变，合并 `[1,3]` 和 `[2,6]` → `[1,6]`，后续无重叠，直接保留。

#### 4. 关键点解释

1. **排序的作用**：  
   - 确保所有可合并的区间在排序后连续，只需检查相邻区间即可。
2. **合并条件**：  
   - 当前区间的左端点 `a` ≤ 已合并区间的右端点 `right`，则需合并。
3. **时间复杂度**：  
   - 排序 `O(n log n)`，遍历 `O(n)`，总时间复杂度 `O(n log n)`。
