### 贪心策略

#### 1. 问题背景

给定一个损坏的计算器，只能进行两种操作：将当前数乘以 2 或减 1。给定起始值 `startValue` 和目标值 `target`，求从 `startValue` 到 `target` 所需的最少操作次数。

---

#### 2. 贪心策略分析

##### 1. 逆向思维

- **核心思想**：从 `target` 逆向操作，逐步逼近 `startValue`。
- **操作规则**：  
  - 若 `target` 是偶数，则逆向操作为除以 2（对应正向的乘 2）。
  - 若 `target` 是奇数，则逆向操作为加 1（对应正向的减 1）。
- **终止条件**：当 `target ≤ startValue` 时，剩余操作次数为 `startValue - target`（只能通过加 1 操作完成）。

##### 2. 策略步骤

1. **逆向操作循环**：当 `target > startValue` 时：
   - 若 `target` 是偶数，`target /= 2`。
   - 若 `target` 是奇数，`target += 1`。
   - 每次操作后，计数器 `ret++`。
2. **补足剩余差值**：最终操作次数为 `ret + (startValue - target)`。

---

#### 3. 正确性证明

##### 1. 贪心选择性质

- **偶数优先**：若 `target` 是偶数，逆向除以 2 能快速缩小与 `startValue` 的差距。
- **奇数处理**：若 `target` 是奇数，必须加 1 变为偶数才能继续逆向操作。
- **数学验证**：
  假设 `target` 是奇数，逆向操作为 `target → target+1 → (target+1)/2`，相当于两步减少 `(target-1)/2`，比正向操作更高效。

##### 2. 最优子结构

- 若某次操作未选择当前最优（如对偶数 `target` 不除以 2），则后续需要更多操作补偿。

##### 3. 示例验证

- **示例 1**：`startValue=3`, `target=8`
  逆向操作：`8 → 4 → 2 → 3`（3 次操作），剩余差值 `3-3=0`，总次数 `3`。
  正向操作：`3 → 6 → 7 → 8`（3 次操作）。
- **示例 2**：`startValue=2`, `target=5`
  逆向操作：`5 → 6 → 3 → 4 → 2`（4 次操作），剩余差值 `2-2=0`，总次数 `4`。
  正向操作：`2 → 4 → 3 → 6 → 5`（4 次操作）。

#### 4. 关键点解释

1. **逆向操作的有效性**：  
   - 逆向操作通过减少 `target` 的规模，避免正向操作中乘 2 可能导致的数值爆炸。
2. **操作次数的计算**：  
   - 当 `target ≤ startValue` 时，只需通过 `startValue - target` 次加 1 操作即可完成。
3. **时间复杂度**：  
   - 每次循环至少将 `target` 减少一半，时间复杂度为 `O(log(target))`。
