### 贪心策略

#### 1. 问题背景

给定一个整数数组 `nums`，要求选出若干元素，使得它们的和最大且能被3整除。若所有元素的和本身能被3整除，直接返回该和；否则，通过移除部分元素调整余数，使剩余和满足条件。

![image-20250315165700260](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250315165700445.png)

1.  **余数分类**：任意整数除以 3 的余数只有三种可能：0、1、2。因此数组中的所有数也可以按余数分成三类：
    -   余数为 0 的数：对总和没有影响，直接加进去。
    -   余数为 1 的数：如果总和除以 3 的余数为 1，我们需要减去一个余数为 1 的数，或者减去两个余数为 2 的数。
    -   余数为 2 的数：如果总和除以 3 的余数为 2，我们需要减去一个余数为 2 的数，或者减去两个余数为 1 的数。
2.  **贪心策略**：为了使总和尽可能大，我们要尽量少地减少总和。因此在需要调整时，优先移除最小的数或最小的组合。

---

#### 2. 解题步骤

1.  **计算总和**：遍历数组，累加所有数字，得到总和 `sum`。

2.  分类记录最小值：

    -   用 `x1` 和 `x2` 分别记录**最小的两个余数为 1 的数**。

    -   用 `y1` 和 `y2` 分别记录**最小的两个余数为 2 的数**。

        >为了确保 `x1` 和 `x2` 总是前两个最小的余数为 1 的数（`y1`、`y2` 同理），每当我们遍历到一个新数 `x` 时：
        >
        >-   若 `x % 3 == 1`：
        >    -   如果 x < x1，说明 x 比当前最小值还小，那么：
        >        -   `x2 = x1`（原来的最小值变成次小值），
        >        -   `x1 = x`（更新最小值为当前值）。
        >    -   否则，如果 x < x2，但不小于 x1，说明 x 是第二小的值，那么：
        >        -   `x2 = x`（直接更新次小值）。
        >
        >`y1` 和 `y2` 的维护逻辑完全相同。
        >
        >---
        >
        >**使用 `sort` 的可行性**
        >
        >-   可以使用 `sort` 对余数为1和余数为2的元素分别排序，然后取最小的1个或2个元素。
        >-   但这种方法的时间复杂度较高：
        >    -   每次插入新元素后都需要排序，时间复杂度为 `O(n log n)`。
        >    -   而直接维护最小两个元素的时间复杂度为 `O(n)`。

3.  调整总和：

    -   若 `sum % 3 == 0`：总和本身已经是 3 的倍数，直接返回 `sum`。
    -   若 `sum % 3 == 1`：需要移除最小的余数为 1 的数 `x1`，或者移除两个最小的余数为 2 的数 `y1 + y2`，选择保留较大的结果。
    -   若 `sum % 3 == 2`：需要移除最小的余数为 2 的数 `y1`，或者移除两个最小的余数为 1 的数 `x1 + x2`，同样选择保留较大的结果。

**贪心的核心在于：每次调整时，尽可能少地减少总和。**通过预先记录最小的余数为 1 和余数为 2 的数，我们可以在需要调整时快速做出最优决策。

- **余数为0**：直接返回 `sum`。
- **余数为1**：比较移除 `x1` 或移除 `y1 + y2` 后的最大值。
- **余数为2**：比较移除 `y1` 或移除 `x1 + x2` 后的最大值。

---

#### 3. 正确性证明

**余数调整的数学依据**

- **余数为1时**：
  - 移除1个余数为1的元素：`sum - x1`，余数为 `(sum %3) -1 = 0`。
  - 移除2个余数为2的元素：`sum - (y1 + y2)`，余数为 `(sum %3) - (2+2) %3 = 0`。
- **余数为2时**：
  - 移除1个余数为2的元素：`sum - y1`，余数为 `(sum %3) -2 = 0`。
  - 移除2个余数为1的元素：`sum - (x1 + x2)`，余数为 `(sum %3) - (1+1) %3 = 0`。

**为什么维护/更新最小值的数量是两个，而不是1个或者3个及以上：**

-   **维护一个最小值**：无法应对需要移除两个数字的情况。
-   **维护两个最小值**：正好能满足在任何情况（单个或两个数字移除）的需求，且效率最高。
-   **维护三个或更多**：超出问题所需，增加额外的复杂度而无收益。

---

#### 4. 关键点解释

1. **余数分类与调整**：根据余数选择移除策略，确保总和能被3整除。
2. **维护最小元素**：记录余数为1和2的最小两个元素，快速找到最优移除组合。
3. **边界处理**：当某种调整方式不可行时（如余数为1但无余数为2的两个元素），自动选择另一种方式。

#### 5. 复杂度分析

- **时间复杂度**：O(n)，遍历数组一次。
- **空间复杂度**：O(1)，仅需常数空间存储关键变量。
