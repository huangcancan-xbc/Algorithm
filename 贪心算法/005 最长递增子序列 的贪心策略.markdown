### 算法原理

#### 1. 问题分析

题目要求找到数组中最长递增子序列（LIS）的长度。递增子序列的特点是：元素严格递增且顺序与原数组一致。例如，数组 `[3, 4, 1, 2]` 的 LIS 是 `[3, 4]` 或 `[1, 2]`，长度为 2。

![image-20250306204912663](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250306204912908.png)

---

#### 2. 贪心策略的核心思想

我们维护一个数组（通常命名为 `ret` 或 `tails`），它的作用不是保存真实的子序列，而是保存各个长度的递增子序列中 **最小可能的结尾（尾部）值**。这个数组满足这样一个性质：`ret[i]` 表示所有长度为 `i+1` 的递增子序列中，尾部值最小的那个数字。

**为什么这样设计？**
因为尾部值越小，后续接入新的数字的可能性就越大，也就更容易形成更长的递增子序列（假设两个数 3 和 4，要形成递增趋势，5 既然能接在 4 后面，那么铁定也能接在 3 后面，即存数时，仅需存储那个较小值）

-   **目标**：维护一个数组 `ret`，其中 `ret[i]` 表示所有长度为 `i+1` 的递增子序列中 **最小的末尾值**。
-   **原理**：末尾值越小，后续越容易找到更大的数来扩展子序列。例如，末尾为 3 的子序列比末尾为 5 的子序列更容易接上 4。

>#### 贪心策略的本质
>
>该算法的贪心思想体现在：**在每个可能的子序列长度下，始终选择最小的末尾值**。这一选择基于以下关键洞察：较小的末尾值为后续元素提供了更大的扩展潜力。例如，若存在两个长度为 2 的子序列 `[a, b]` 和 `[c, d]`，其中 `b < d`，则后续元素 `x` 只要大于 `b` 就能扩展前一个子序列，而可能需要更大的 `x`（`x > d`）才能扩展后一个子序列。因此，保留较小的末尾值更有利于全局最优。
>
>#### 为何需要贪心策略？
>
>1.  **灵活性最大化**：较小的末尾值降低了后续扩展的“门槛”，使更多元素有机会接续，从而可能形成更长的子序列。
>2.  **高效维护长度**：通过替换操作（而非直接插入），在保证长度不变的前提下优化末尾值，确保每一步的局部最优最终导向全局最优解。
>
>#### 如何理解替换操作？
>
>-   **替换不影响长度**：替换时仅更新某一位置的末尾值，并未改变 `ret` 数组的长度。例如，将 `ret = [2, 5, 7]` 替换为 `[2, 3, 7]`，长度仍为 3，但第二个位置的末尾值更小，后续遇到 `4` 时能接续，而原末尾值 `5` 无法做到。
>-   **隐含全局最优**：虽然 `ret` 数组可能不构成真实的子序列，但其长度准确反映了最长递增子序列的长度。这是因为替换操作始终维护了“各长度下最小末尾值”的性质，确保后续元素的扩展潜力最大化。

#### 3. 具体步骤

**初始化**：将第一个元素放入 `ret`。对于每个遍历到的数字 `nums[i]`，我们有两种情况：

**情况 1：`nums[i]` 大于 `ret` 数组的最后一个元素**

-   **操作**：直接将 `nums[i]` 添加到 `ret` 的末尾。

-   **原因**：如果当前数字大于目前最长递增子序列的尾部，则可以直接延长这个子序列。

-   **示例**：

    假设当前 `ret = [2, 5, 7]`，遇到数字 `9`，由于 `9 > 7`，所以新的 `ret` 变为 `[2, 5, 7, 9]`。

**情况 2：`nums[i]` 不大于 `ret` 数组的最后一个元素**

-   **操作**：使用二分查找，在 `ret` 中找到第一个大于等于 `nums[i]` 的位置，然后用 `nums[i]` 替换那个位置的数值。

-   **原因**：替换后的 `ret` 虽然可能不再是一个真实的子序列，但它保持了“每个长度的子序列的尾部尽可能小”的性质，从而为后续可能的扩展提供了更好的机会。

-   **示例**：

    假设当前 `ret = [2, 5, 7]`，遇到数字 `3`，通过二分查找找到位置 `1`（因为 `5` 是第一个不小于 `3` 的数），将 `5` 替换为 `3`，得到新的 `ret = [2, 3, 7]`。

    这样后续如果遇到比 `7` 稍大的数字，比如 `8`，就可以接在 `7` 后面；同时，`3` 替换 `5` 意味着子序列在第二个位置上更“轻”，未来更容易接入更多数字。

>   [!IMPORTANT]
>
>   1.  若当前元素 `nums[i]` 大于 `ret` 的最后一个元素，直接将其加入 `ret`（扩展最长子序列）。
>   2.  否则，通过二分查找找到 `ret` 中第一个大于等于 `nums[i]` 的位置，替换该位置的值为 `nums[i]`（优化该长度的最小末尾）。

#### 4. 为什么替换不会影响最终答案

虽然替换操作可能让 `ret` 数组中的数字不一定能组成原数组中的一个完整子序列，但这种做法保证了：

-   **关键性质**：`ret` 始终保持递增。

-   **序列长度不变**：我们只关心最终 `ret` 数组的长度，这个长度等于最长递增子序列的长度。
-   **最小尾部策略**：对于任意长度的子序列，保持最小尾部能保证更大的灵活性，帮助后续数字接上去形成更长的序列。
-   **长度正确性**：最终 `ret` 的长度即为 LIS 的长度，因为每一步都在保证最长可能长度的前提下优化了末尾值。

换句话说，虽然 `ret` 不是一个“真实”的递增子序列，但它隐含地维护了各个长度递增子序列的最佳可能状态。

#### 5. 使用二分查找的意义

由于 `ret` 数组始终保持有序（每个元素都比前一个小或等），我们可以用二分查找在 O(log⁡n)的时间内找到第一个大于等于当前数字的位置。这使得整个算法的时间复杂度降低到 O(nlog⁡n)，相比传统的 O(n^2) 方法要高效很多。

#### 6. 示例分析

以 `nums = [4, 5, 6, 1, 2, 3]` 为例：

1. **初始 `ret = [4]`**。
2. **处理 5**：5 > 4，扩展为 `[4, 5]`。
3. **处理 6**：6 > 5，扩展为 `[4, 5, 6]`。
4. **处理 1**：找到位置 0，替换为 `[1, 5, 6]`。
5. **处理 2**：找到位置 1，替换为 `[1, 2, 6]`。
6. **处理 3**：找到位置 2，替换为 `[1, 2, 3]`。
    最终 `ret` 长度为 3，对应 LIS `[1, 2, 3]`。

#### 7. 总结

-   **贪心策略**：每次尽可能用更小的数字来更新递增子序列的尾部，从而为后续扩展留出更多空间。
-   **二分查找**：快速确定需要替换的位置，保持 `ret` 数组的有序性。
-   **结果**：最终 `ret` 数组的长度就是最长递增子序列的长度。
-   **时间效率**：O(n log n) 时间复杂度，远优于暴力 O(n²)。
-   **空间效率**：仅需一个长度为 LIS 的数组，空间复杂度 O(n)。

这种方法也常被称为 **耐心排序（Patience Sorting）** 算法，因为其过程类似于打牌时将牌放在不同的堆里，每个堆的顶牌尽可能小，从而最后堆的数量就代表最长递增子序列的长度。