### 贪心策略

#### 题目概述（最长递增子序列的简化版）

我们需要判断一个数组中是否存在三个递增的元素，顺序递增但无需连续。例如，数组 `[1,2,3,4,5]` 中存在 `(1,2,3)`，返回 `true`。

---

我们希望找到 **最小的两个数 a 和 b**，然后寻找是否有 **第三个数比这两个数都大**。**核心目标**：维护两个变量 `a` 和 `b`，分别表示当前找到的递增序列中的最小值和中间值。通过不断更新这两个变量，使得后续元素更容易满足条件。

维护两个变量：

-   `a`：目前遇到的最小值
-   `b`：当前的次小值（比 `a` 大的最小值）

**如果出现一个数比 `b` 还大，说明找到了 `a < b < c`，可以返回 `true`。**

**直观比喻**：

- 假设你在寻找三个逐渐升高的台阶（三元组）。
- `a` 是你当前找到的最矮的台阶，`b` 是比 `a` 高的下一级台阶。
- 当你遇到一个新的台阶时，有三种情况：
  1. 它比 `b` 高 → 找到完整的三个台阶，完成任务！
  2. 它介于 `a` 和 `b` 之间 → 用这个新台阶替换 `b`，让后续更容易找到更高的台阶。
  3. 它比 `a` 还矮 → 替换 `a` 为更矮的台阶，后续可能找到更低的 `b`。

#### 算法步骤

1. **初始化**：
   - `a` 设为数组第一个元素，`b` 设为无穷大（表示尚未找到中间值）。

2. **遍历数组**：
   - 对每个元素 `nums[i]`，依次判断：
     - **情况1**：`nums[i] > b` → 发现第三个数，直接返回 `true`。
     - **情况2**：`nums[i] > a` → 更新 `b` 为 `nums[i]`（保持 `b` 尽可能小）。
     - **情况3**：`nums[i] <= a` → 更新 `a` 为 `nums[i]`（保持 `a` 尽可能小）。

---

#### 为什么是贪心？

- **局部最优选择**：每一步都尽可能让 `a` 和 `b` 最小，为后续留出更大空间。
- **无后效性**：更新 `a` 和 `b` 不影响已找到的潜在三元组，因为新的 `a` 可能开启更优的序列。

#### 正确性证明

假设存在递增三元组 `(x, y, z)`，其中 `x < y < z`。根据算法规则：
- 当遍历到 `y` 时，`a` 可能已经是某个比 `x` 更小的值，或者保持为 `x`。
- 无论 `a` 如何变化，`b` 会被更新为 `y` 或更小的值（比如在 `y` 之后遇到比 `y` 小的数）。
- 当遍历到 `z` 时，`z` 必然大于当前的 `b`（因为 `b` 保存的是 `y` 或更小的中间值），从而触发条件返回 `true`。

#### 实例演示

以数组 `[5, 1, 6, 2, 3]` 为例：
1. 初始：`a = 5`, `b = ∞`。
2. 遍历到 `1`：`1 < a` → `a = 1`。
3. 遍历到 `6`：`6 > a` → `b = 6`。
4. 遍历到 `2`：`2 < b` 但 `2 > a` → `b = 2`（更新为更小的中间值）。
5. 遍历到 `3`：`3 > b` → 返回 `true`（三元组为 `1, 2, 3`）。
