在排列组合、全排列、组合等类型题目中，全局变量和局部变量的选择影响代码的效率和易读性。下面详细讲解 **全局变量** 的优点、为何推荐，以及某些情况下 **局部变量传参** 的必要性和效率问题。

------

### 1. **为什么推荐使用全局变量？**

全局变量是指在类或程序的顶层定义的变量，在整个递归调用过程中共享和使用，不需要通过函数参数不断传递。

#### **优点**：

1. **代码简洁**：

   - 全局变量可以直接访问，不需要在递归函数的参数中传来传去。
   - 比如路径 `path` 和结果集 `ret`，通过全局变量，递归逻辑更清晰，避免重复传递，简化函数签名。

2. **共享递归状态**：

   - 在排列组合问题中，经常需要维护一个当前的路径（`path`）和最终的结果（`ret`）。

   - 这些状态随着递归深度变化而更新，使用全局变量可以直接更新状态，无需频繁返回或传递。

   - 举例：

     ```cpp
     vector<int> path;
     vector<vector<int>> ret;
     
     void dfs()
     {
         path.push_back(1);
         // ...
         path.pop_back(); // 回溯时自动恢复
     }
     ```

     如果用局部变量，每次都要显式传递、拷贝路径，导致代码复杂且效率低。

3. **避免拷贝**：

   - 如果路径 `path` 是局部变量，每次递归都要将当前路径传递到下一层。路径作为参数传递时，可能涉及深拷贝，尤其在递归深度较深时，拷贝会导致性能下降。

4. **适用于大多数排列组合问题**：

   - 许多排列组合问题只需在递归完成后清空状态即可，不涉及复杂的传参逻辑，全局变量可以很好地满足需求。

#### **典型场景**：

全局变量特别适合以下情况：

- 路径 `path` 和结果集 `ret` 在整个递归过程中共享。
- 状态的更新（如路径加入、弹出）是递归的一部分，而不需要中途返回。
- 避免频繁的变量拷贝和传参。

------

### 2. **为什么某些题目必须使用局部变量传参？**

虽然全局变量有很多优势，但在某些特定情况下，必须使用局部变量传参，尤其是当问题规模大、状态复杂时。以下是原因和原理：

#### **原因 1：全局变量的“污染”问题**

全局变量在递归中共享，但某些特定题目中，每一层递归对状态的依赖可能会出现冲突。

- **问题**：递归过程中，每一层可能需要不同的状态，如果用全局变量，这些状态会被覆盖或污染，导致结果错误。
- **解决**：使用局部变量传递，确保每层递归独立处理自己的状态。

#### **原因 2：避免递归栈中的冗余状态**

在某些复杂场景（如需要深拷贝状态或回溯较多的情况下），全局变量会导致性能问题：

- **路径拷贝问题**：全局变量 `path` 是共享的，在递归深度较大时，状态的维护可能涉及多次操作（如加入、移除），每次操作都需要同步到全局变量，导致性能开销。
- **解决**：局部变量传递，避免多次操作全局变量，递归退出后局部变量自动销毁，效率更高。

#### **原因 3：特定题目中递归树的“剪枝”效率**

- **全局变量可能导致超时**：在某些排列组合问题中（如路径需要频繁更新或提前退出的场景），全局变量的操作影响整个递归树的效率，可能导致超时。
- 局部变量传参更快：
  - 局部变量通过递归函数参数传递，减少了全局变量的读写操作。
  - 每一层的状态独立于其他层，剪枝时可以快速退出递归。

#### **典型场景**：

局部变量传参适合以下情况：

- 状态在每层递归中独立，不能共享（如当前路径、当前节点）。
- 问题规模较大，递归深度深，使用局部变量减少全局变量的更新成本。
- 需要频繁进行剪枝操作，比如提前退出递归。

------

### 3. **性能分析：全局变量 vs 局部变量**

| **特性**       | **全局变量**                         | **局部变量传参**               |
| -------------- | ------------------------------------ | ------------------------------ |
| **变量共享**   | 所有递归共享状态，路径可直接更新     | 每层递归状态独立，不干扰其他层 |
| **代码复杂度** | 代码简洁，无需传递参数               | 参数传递繁琐，尤其在多个状态时 |
| **性能**       | 避免频繁拷贝，但可能导致全局更新冗余 | 每层递归状态独立，适合复杂剪枝 |
| **适用场景**   | 常见排列组合问题，递归简单           | 剪枝需求高、递归树复杂的问题   |

------

### 4. **举例分析**

#### **适合全局变量的例子**：

组合求和问题 `Combination Sum`：

- 每次递归只需要共享当前路径 `path` 和结果集 `ret`。
- 当前路径通过 `path.push_back()` 和 `path.pop_back()` 更新，全局变量简化逻辑。
- 不需要复杂的剪枝，适合全局变量。

代码示例：

```cpp
vector<int> path;
vector<vector<int>> ret;

void dfs(vector<int>& candidates, int pos, int sum)
{
    if (sum == target)
    {
        ret.push_back(path);
        return;
    }
    
    for (int i = pos; i < candidates.size(); i++)
    {
        path.push_back(candidates[i]);
        dfs(candidates, i, sum + candidates[i]);
        path.pop_back(); // 回溯
    }
}
```

------

#### **适合局部变量的例子**：

全排列问题 `Permutations`（需要交换元素处理）：

- 每次递归需要基于当前数组的状态进行操作。
- 使用全局变量可能导致状态冲突，局部变量通过参数传递避免污染。

代码示例：

```cpp
void dfs(vector<int>& nums, int index, vector<vector<int>>& result) 
{
    if (index == nums.size())
    {
        result.push_back(nums);
        return;
    }
    
    for (int i = index; i < nums.size(); i++)
    {
        swap(nums[i], nums[index]); // 交换
        dfs(nums, index + 1, result); // 递归
        swap(nums[i], nums[index]); // 回溯
    }
}
```

------

### 5. **总结**

- **全局变量更推荐**：大多数排列组合问题中，全局变量简化了代码逻辑，尤其是状态可以共享时。
- **局部变量更高效**：当状态在每层递归中独立、需要频繁更新或剪枝时，局部变量通过参数传递避免全局污染，提升性能。

根据问题的递归逻辑选择适合的变量方式，才能写出高效、优雅的代码。