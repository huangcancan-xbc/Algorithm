## 方法一里面的解释：

### 为什么是 `pos == candidates.size()` 而不是 `pos > candidates.size()`？

**原因：**

- **`sum > dest`**: 如果当前和已经超过了目标和 `dest`，就没有必要继续递归下去，因为再继续下去结果肯定不符合要求。（当前和大于目标和，停止继续搜索）
- **`pos == candidates.size()`**: 这是当我们已经遍历完了候选数组中的所有元素时，递归就应该停止。因为我们已经没有更多的元素可以选择了。（已经遍历完所有元素，也应该停止递归）

这两者条件是互相独立的，任何一个满足就可以确保递归能够正确结束，而不会继续无意义地探索已经遍历过的路径。

- `pos == candidates.size()` 说明当前的位置**==已经==等于候选数组的长度，也就是说我们==已经==走到了数组的末尾，没有更多的元素可以选**。==***此时需要停止***==。（简单理解：当我们已经将**`pos == candidates.size()`**的情况进行返回，自然就不存在`pos > candidates.size()`的情况了）
- `pos > candidates.size()` 是不可能发生的情况，因为 `pos` 作为索引，不会超出数组的最大索引。

在C++中，使用 `==` 来比较整数通常是安全的，但是为了保持代码的一致性和可读性，通常也会使用 `>=` 来表示“超出或等于”某个值的情况。

```cpp
if (sum > dest || pos == candidates.size())
{
    return;
}
```

```cpp
if (sum > dest || pos >= candidates.size())
{
    return;
}
```

所以，这两种写法在功能上是等价的。我们可以根据需要选择使用 `==` 或 `>=` 进行条件判断。

## 方法二里面的解释：

```cpp
//方法二：DFS（枚举每一个元素 “出现” 次数）
class Solution
{
public:
    vector<int> path;                               // 存储当前的组合路径
    vector<vector<int>> ret;                        // 存储最终的所有组合
    int dest;                                       // 目标和

    void dfs(vector<int>& candidates, int pos, int sum)
    {
        if (dest == sum)
        {
            ret.push_back(path);                    // 如果当前和等于目标，记录路径并返回
            return;
        }

        if (sum > dest || pos >= candidates.size())
        {
            return;                                 // 超过目标或遍历完所有元素时停止（返回）
        }

        for (int i = 0; i * candidates[pos] <= dest; i++)
        {
            if (i)
            {
                path.push_back(candidates[pos]);    // i不为0时，加入当前元素
            }

            dfs(candidates, pos + 1, sum + i * candidates[pos]);// DFS，继续遍历下一个元素
        }

        for (int i = 1; i * candidates[pos] <= dest; i++)
        {
            path.pop_back();                        // 回溯，移除最后加入的元素
        }
    }

    vector<vector<int>> combinationSum(vector<int>& candidates, int target)
    {
        dest = target;                              // 记录目标和
        dfs(candidates, 0, 0);
        return ret;
    }
};
```

参照决策树配套的 **07 决策树.jpg** 文件，我们可以把问题看作一个逐层决策的过程。每一层决策尝试一个数字的不同出现次数（从 0 次到目标允许的最大次数），逐步累加当前的和。如果发现某条路径的和等于目标值，就把这条路径记录下来；如果和超过目标值，或者所有数字都尝试完，就回退到上一层，尝试其他可能。整个过程可以用一个 **决策树** 来理解：从根节点开始，每一层是一个数字，分支是这个数字的不同出现次数，直到叶子节点找到符合条件的解，或者超出目标值停止。最终，树的遍历记录了所有可能的数字组合。

### **为什么递归从0开始，回溯却要从1开始？**

- 因为我们在枚举每一个数字出现的次数的时候，需要考虑某个数字出现0次的情况。比如有[2,3]，目标值为3的情况，需要枚举2出现0次，3出现一次的情况；故递归要从0开始。

- 我们只在出现次数不为0的时候才将可能结果加入到了路径中，自然回溯也只用考虑将加入过路径的可能结果进行回溯。不为0的情况都要进行回溯，自然也就应该从1开始回溯了。

## 优化版：

```cpp
for (int i = 0; sum + i * candidates[pos] <= dest; i++)
{
    ……
}
```

在优化版代码中，`for (int i = 0; sum + i * candidates[pos] <= dest; i++)` 的逻辑是为了减少无意义的递归，尽量在循环阶段就判断是否继续，避免走到递归函数里再进行判断。

------

**通俗讲解：**

这个循环的核心在于：**动态计算当前数字在组合中最多能选几次**。如果某个数字在当前路径中选多次后，导致路径和超过目标 `dest`，那后续的次数就不需要再尝试了。所以用 `sum + i * candidates[pos]` 这个公式提前计算，确保只在路径和不超过目标的前提下才继续递归。

### 每一部分的作用：

1. **`sum`**：表示当前路径的数字和，代表已经选了的数字加起来的值。
2. **`i \* candidates[pos]`**：表示当前数字（`candidates[pos]`）被选了 `i` 次时，对总和的影响。
3. `sum + i * candidates[pos] <= dest`：
   - 检查：如果当前路径和（`sum`）加上选 `i` 次当前数字的和，还没有超过目标值 `dest`，就可以继续选，否则停止尝试。

------

### 举例：

假设当前路径和为 `sum = 3`，当前处理的数字为 `candidates[pos] = 2`，目标和 `dest = 7`：

- **`i = 0`**：不选当前数字，`sum + i * 2 = 3 + 0 * 2 = 3`，继续递归；
- **`i = 1`**：选 1 次当前数字，`sum + i * 2 = 3 + 1 * 2 = 5`，继续递归；
- **`i = 2`**：选 2 次当前数字，`sum + i * 2 = 3 + 2 * 2 = 7`，继续递归；
- **`i = 3`**：选 3 次当前数字，`sum + i * 2 = 3 + 3 * 2 = 9`，超过目标 `dest = 7`，停止循环，不再尝试更多次数。

通过这个判断，我们有效地减少了递归次数，只探索合理的路径。

------

### 优化的效果：

相比之前直接递归，**在循环中加入这个判断可以节省时间**：

- 当数字选得过多，超出目标时，会在循环中停止，而不再进入递归。
- 避免了不必要的回溯操作，使算法更高效。

### 优化点总结

1. **减少不必要的循环：** 在`dfs`函数中，内外循环的条件更为简洁，避免了重复的检查。
2. **清晰的回溯操作：** 在回溯部分，只有当`i != 0`时，才进行`path.push_back`和`path.pop_back`，避免了无意义的操作。
3. **更简洁的代码：** 代码结构更简洁，避免了多余的判断和不必要的计算。