> 两种代码的解题思路其实一模一样，不过是写法不同，看个人理解吧。

### 1. 代码一的思路和决策树解析

这段代码是通过 **回溯算法（Backtracking）** 来生成所有可能的排列，同时筛选出符合条件的排列。核心思想是构造一个 **决策树**，每一步递归中尝试将一个未使用的数字放入当前排列的位置，并判断是否满足题目给定的条件（`i % pos == 0 || pos % i == 0`）。如果条件满足，则继续构造下一步，直到排列完成。

------

### 1. 核心思路

1. **排列构造：**
   - 使用 `dfs(pos)` 表示正在确定排列的第 `pos` 个位置。
   - 每次递归尝试把一个数字（从 `1` 到 `n`）放到 `pos` 位置。
   - 在决策过程中使用一个标记数组 `check` 来避免重复选择已经使用过的数字。
2. **有效性检查：**
   - 当数字 `i`被放置在第 `pos`个位置时，必须满足条件：`i % pos == 0` 或`pos % i == 0`。
   - 如果条件不满足，则剪枝（跳过该分支）。
3. **递归终止：**
   - 当 `pos > n` 时，表示当前排列已经完成，并且符合题意，计数器 `ret++`。
4. **回溯：**
   - 在递归返回时，撤销本次选择，恢复现场（将 `check[i]` 标记为未使用），从而尝试其他可能的数字。

------

### 2. 决策树结构

#### 决策树定义：

- **根节点**： 表示排列的第 0 个位置（开始状态）。
- **每一层**： 表示排列的第 `pos` 个位置（递归深度）。
- **分支**： 每个分支表示选择一个数字 `i` 放入当前位置 `pos`。
- **叶子节点**： 表示排列已经构造完成。

#### 示例决策树：`n = 3`

1. **根节点：** 从第 1 个位置开始。
   - 在第 1 个位置，我们可以选择 `{1, 2, 3}`。
2. **第一层决策：** 决定第 1 个位置的数字。
   - 如果选择 `1`：进入下一层决策（第 2 个位置）。
   - 如果选择 `2`：进入下一层决策（第 2 个位置）。
   - 如果选择 `3`：进入下一层决策（第 2 个位置）。
3. **第二层决策：** 决定第 2 个位置的数字。
   - 如果第 1 个位置是 `1`，第 2 个位置可以是 `{2, 3}`。
   - 如果第 1 个位置是 `2`，第 2 个位置可以是 `{1, 3}`。
   - 如果第 1 个位置是 `3`，第 2 个位置可以是 `{1, 2}`。
4. **第三层决策：** 决定第 3 个位置的数字。
   - 按照类似逻辑，依次尝试剩余的数字。
5. **叶子节点：** 当排列完成时，检查是否满足题目要求，若满足则计数器 `ret++`。

------

#### 决策树示例展开（`n = 3`）：

```plaintext
        Start
       /  |  \
      1   2   3        (第一层，pos=1，选择1、2或3)
     /|   |\   |\
    2 3   1 3  1 2     (第二层，pos=2，尝试剩余数字)
   /   \  /   \  / \
  3    2 3    1 2   1  (第三层，pos=3，尝试剩余数字)
```

每条从根节点到叶子节点的路径都是一个排列。例如：

- `1 → 2 → 3`，如果满足题目条件，则计数器加一。
- `2 → 3 → 1`，如果满足题目条件，则计数器加一。

------

### 3. 决策树剪枝

为了减少不必要的递归，代码中通过以下手段进行了 **剪枝**：

1. **条件判断：**
   - 在每一步递归中，数字 `i` 只有在 `i % pos == 0` 或 `pos % i == 0` 时才会继续尝试。
   - 如果不满足条件，直接跳过分支，避免进一步递归。
2. **标记数组：**
   - 使用 `check[i]` 避免数字重复使用，从而减小搜索空间。

这些剪枝大幅减少了搜索空间，提高了效率。

------

### 4. 时间复杂度分析

1. **排列生成：**
   - 在最坏情况下，回溯会生成所有可能的排列，即 `n!` 种。
2. **剪枝减少搜索空间：**
   - 每个位置的数字选择受题目条件限制，因此实际生成的排列数远小于 `n!`。
3. **总体复杂度：**
   - 时间复杂度介于 `O(n!)` 和 `O(n)` 之间，具体取决于 `n` 的大小以及题目条件的约束。

------

### 5. 总结

这段代码的思路是基于 **回溯算法**，通过构造 **决策树** 来生成所有可能的排列，并在每一步递归中检查是否满足题目要求。通过剪枝（条件判断和标记数组），减少了无效分支的递归，提升了效率。





### 2. 代码二中为什么是`if (pos == n + 1)`？

**`pos` 实际上是一个表示当前递归深度的变量**，可以理解为对应排列中的“位置编号”，相当于从 1 开始的下标。具体来说：

### 1. 理解 `pos` 的作用：

1. `pos` 从 1 开始，一直到 `n`，表示当前递归正在处理的位置编号。
2. 每次递归，`dfs(pos, n)` 的目标是尝试为 **位置编号 `pos`** 填入一个数字。
3. 当递归到 `pos == n + 1` 时，表示已经超出了最后一个位置（即编号为 `n` 的位置），此时说明从 1 到 `n` 的所有位置都已经填充完毕，因此可以计数。

### 2. 关于递归逻辑：

- 假设有 `n` 个位置，从 1 到 `n` 分别需要填充数字。
- `pos` 表示当前正在填充的位置，从 1 一直到 `n`。
- **`pos == n + 1` 时退出递归**，因为此时已经完成了所有位置的填充。

### 3. 总结代码对应逻辑：

- **递归从 `pos = 1` 开始**：尝试填充第 1 个位置。
- **递归到 `pos = n + 1` 时**：说明第 1 到第 `n` 个位置都已经被合法填充，完成一个排列。
- 所以，`pos` 的取值范围是从 1 到 `n`，`pos == n + 1` 表示递归终止条件。

### 4. 示例分析（`n = 3`）：

如果 `n = 3`，位置编号为 `1, 2, 3`，流程如下：

1. `pos = 1`：尝试为位置 1 填一个数字。
2. `pos = 2`：尝试为位置 2 填一个数字。
3. `pos = 3`：尝试为位置 3 填一个数字。
4. **`pos = 4`**：说明 1, 2, 3 都已经合法填充，完成一个排列。

因此，`pos` 实际上是一个表示递归深度的变量，同时可以看成从 1 开始的下标。





### 3. 为什么代码一用的是 `pos > k`？

两种写法在本质逻辑上是完全相同的，`if (pos > k)` 和 `if (pos == n + 1)` 在语义上是等价的。代码一用 `pos > k` 是因为它把 `k` 赋值为输入的 `n`，所以用 `pos > k` 的写法更自然。而代码二直接传递 `n` 作为参数，因此用 `pos == n + 1` 更直观。

具体原因分析如下：

### 1. `pos` 的作用

- `pos` 表示当前正在递归处理的位置。
- 递归从 `pos = 1` 开始（即第一个位置），不断尝试为位置 `pos` 填充满足条件的数字。
- 当递归深度超过 `n` 时，表示所有 `1` 到 `n` 的位置都已经被合法填充。

### 2. 两种写法的终止条件对比

#### **代码一：`if (pos > k)`**

- `k` 在 `countArrangement` 中被赋值为 `n`，所以这里的条件等价于 `if (pos > n)`。
- 当递归到 `pos > n` 时，说明已经完成了所有位置的填充（因为递归到 `pos = n + 1` 时，表示前 `n` 个位置都被正确填充）。
- 因此，这里表示一个完整的美丽排列，增加计数并返回。

#### **代码二：`if (pos == n + 1)`**

- 这里直接判断是否递归到了位置 `n + 1`。
- 当 `pos == n + 1` 时，说明前 `n` 个位置已经完成填充，当前排列合法，增加计数并返回。

这两种条件从逻辑上是完全一致的，因为 `pos > n` 的第一次成立必然是 `pos == n + 1`。递归深度达到 `n + 1` 的位置时，自然意味着所有位置已经被处理完毕。

### 3. 实际递归行为

无论是 `if (pos > k)` 还是 `if (pos == n + 1)`：

- 当 `pos = n + 1` 时都会返回，递归自然终止。
- 两者都会在所有合法排列完成时增加计数，功能上没有任何区别。

### 4. 总结

两种写法本质上是完全相同的，只是写法上的差异：

- **代码一** 使用了 `pos > k`，逻辑稍微间接，但也很清晰。
- **代码二** 使用了 `pos == n + 1`，逻辑更直观一些。

无论是哪种写法，递归到位置 `n + 1` 时都会终止并返回，效果完全一致。