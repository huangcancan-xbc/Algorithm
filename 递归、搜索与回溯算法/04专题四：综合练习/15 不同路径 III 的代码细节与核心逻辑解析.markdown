### **问题背景**

**Unique Paths III**（独特路径 III）问题的核心是在一个网格中找到从 **起点** 到 **终点** 的所有唯一路径，要求路径必须覆盖所有非障碍的格子且每个格子只能访问一次。

### **代码概述**

以下是代码的层次概述：

1. **变量和数据结构：**
   - `ret`：用于存储满足条件的唯一路径数量。
   - `dx` 和 `dy`：表示四个方向（上、下、左、右）的移动。
   - `vis`：一个二维布尔数组，用于记录已访问的格子。
   - `n`, `m`：网格的行数和列数。
   - `step`：需要走的总步数，包含起点和终点。
2. **`uniquePathsIII` 函数：**
   - 初始化网格的行数和列数。
   - 遍历网格，统计所有空格子（`grid[i][j] == 0`）的数量，并找到起点（`grid[i][j] == 1`）。
   - 调整 `step` 以包含起点和终点。
   - 从起点位置开始进行深度优先搜索（DFS）。
3. **`dfs` 函数：**
   - 递归地探索所有可能的路径。
   - 当达到终点（`grid[i][j] == 2`）时，检查路径长度是否等于所需的 `step`。如果是，则 `ret` 增加。
   - 标记当前格子为已访问，避免重复访问，并在递归完成后回溯。

------

### **1. 为什么 `step` 需要增加 2（`step += 2`）？**

**`step` 的目的：**

- `step` 变量表示完成一条有效路径所需访问的总格子数。这包括：
  - 所有 **空格子**（`grid[i][j] == 0`）。
  - **起点**（`grid[i][j] == 1`）。
  - **终点**（`grid[i][j] == 2`）。

**初始计数：**

- 在遍历网格时，代码统计了所有 `grid[i][j] == 0`的格子数量，并相应地增加了 `step`。但这个计数 不包括：
  - 起点格子。
  - 终点格子。

**为什么要加 2？**

- **起点格子**：因为路径的起点也是需要访问的第一个格子，所以必须计入总步数。
- **终点格子**：路径的终点也是需要访问的最后一个格子，同样需要计入总步数。

因此，为了包含起点和终点两个格子，代码需要将 `step` 增加 2：

```cpp
step += 2;
```

**举例说明：**

- 假设网格中有 5 个空格子（`0`）、1 个起点（`1`）和 1 个终点（`2`）。
- 初始时，`step` 统计了 5 个空格子。
- 增加 2 后，`step = 7`，包括了起点和终点。

------

### **2. 为什么初始调用 `dfs` 时传递 `1` 作为 `count`（`dfs(grid, x1, y1, 1)`）？**

**理解 `count`：**

- `count` 变量用于跟踪当前路径中已访问的格子数。
- 它从 `1` 开始，因为起点格子已经被计入路径中。

**为什么从 1 开始？**

- 当 DFS 开始时，算法已经位于起点格子（`x1`, `y1`）。因此，这个格子应被视为路径的第一个格子，`count` 应初始化为 `1`。

**代码片段：**

```cpp
vis[x1][y1] = true; // 标记起点格子为已访问
dfs(grid, x1, y1, 1); // 从起点开始 DFS，初始 count 为 1
```

**替代情景：**

- 如果 `count` 初始化为 `0`，则起点格子不会被计入路径，导致总步数不正确，可能漏掉有效路径。

------

### **3. 为什么将 `grid[x][y] != -1` 改为 `grid[x][y] == 0` 是错误的？**

**原始条件：**

```cpp
if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] != -1 && !vis[x][y])
```

- **目的**：允许 DFS 移动到任何在网格边界内、不是障碍物（`-1`），且未被访问过的格子。

**提议的修改：**

```cpp
if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == 0 && !vis[x][y])
```

- **效果**：限制 DFS 只能移动到空格子（`0`）。

**为什么这种修改是错误的？**

1. **无法到达终点：**
   - 终点通常标记为 `grid[x][y] == 2`。
   - 如果条件改为 `grid[x][y] == 0`，DFS 将 **无法** 移动到终点格子，导致无法完成任何有效路径。
2. **失去灵活性：**
   - 原始条件允许移动到空格子（`0`）和终点（`2`），这是完成路径所必需的。
   - 限制为 `grid[x][y] == 0` 会排除终点，路径无法结束。
3. **路径验证失效：**
   - DFS 需要在到达终点时验证是否所有必要的格子都已被访问（`count == step`）。
   - 如果终点无法被访问，这一验证将无法进行，路径验证变得无意义。

**结论：**

- 条件 `grid[x][y] != -1` 旨在包括空格子（`0`）和终点（`2`），这对于找到完整的路径是必要的。
- 将其改为 `grid[x][y] == 0` 会阻止算法访问终点，从而无法找到任何有效路径。

------

### **总结**

- **`step += 2`**：用于将起点和终点纳入需要访问的总步数中，确保路径包含这两个关键格子。
- **`dfs(grid, x1, y1, 1)`**：初始化 DFS 时，`count` 为 `1`，因为起点已经被计入路径。
- **条件 `grid[x][y] != -1`**：允许 DFS 访问空格子和终点，确保可以完成路径。将其改为 `grid[x][y] == 0` 会阻止访问终点，导致无法找到有效路径。