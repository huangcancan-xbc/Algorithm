## 理解代码中的剪枝操作

代码中的 **剪枝** 问题，主要用来跳过重复的排列，从而避免生成重复的结果。

### 条件解释：

```cpp
if (check[i] == true || (i != 0 && nums[i] == nums[i - 1] && check[i - 1] == false))
```

**1. `check[i] == true`**

- **作用：** 如果当前元素 `nums[i]` 已经被使用（即在当前递归路径中已经加入到 `path`），那么就跳过。
- **原因：** 每次递归时只能选择尚未使用的数字。`check[i]` 记录了每个数字是否已经使用过，避免重复选择同一个元素。

**2. `(i != 0 && nums[i] == nums[i - 1] && check[i - 1] == false)`**

- **作用：** 如果当前元素 `nums[i]` 和它前面的元素 `nums[i-1]` 相等，并且前一个元素 `nums[i-1]` 还没有被使用，就跳过。
- 原因：这是为了避免生成重复排列的关键部分。通过排序，所有相等的元素会相邻。如果在递归中直接选择 `nums[i]` 而没有先选择 `nums[i-1]`，会导致重复的排列。例如：
  - 假设输入为 `[1, 1, 2]`，排列 `[1, 1, 2]` 和 `[1, 1, 2]` 是重复的。
  - 在递归中，如果前一个相同的元素（`nums[i-1]`）没有被使用，而直接使用了当前元素（`nums[i]`），就会出现重复排列。
- **如何避免：** 通过要求必须先使用 `nums[i-1]`（即 `check[i-1] == true`），确保每次递归中，只有在前一个相同元素被使用的情况下，才能使用当前的元素。

------

### 为什么这样写可以避免重复？

假设输入是 `[1, 1, 2]`：

1. **排序后的数组：** `[1, 1, 2]`。
2. 遍历过程中：
   - 第一次选择第一个 `1`（`nums[0]`），然后再选择第二个 `1`（`nums[1]`），不会跳过。
   - 如果没有选择第一个 `1`（`nums[0]`），直接选择第二个 `1`（`nums[1]`），就会被 `(i != 0 && nums[i] == nums[i - 1] && check[i - 1] == false)` 条件剪枝，避免生成重复结果。
3. **最终结果：** 通过这种逻辑，可以确保每次相同的数字按固定的顺序被使用，从而避免重复排列。

------

### 直观理解：

条件 `(i != 0 && nums[i] == nums[i - 1] && check[i - 1] == false)` 的作用是让相同的数字必须按顺序使用，前一个没用过的时候，当前的也不能用。

- 这是因为相同的数字在不同位置时，可能会形成相同的排列，如果没有这个限制，结果中会出现重复的排列。
- 排序之后配合这个条件，可以让递归路径唯一化，每种排列只生成一次。

------

### 示例过程：

假设输入是 `[1, 1, 2]`：

1. **初始化：**
   - `nums = [1, 1, 2]`
   - 排序后依然是 `[1, 1, 2]`。
2. **递归：**
   - **第1层递归：**
     - 选择 `nums[0] = 1`，递归。
   - **第2层递归：**
     - 选择 `nums[1] = 1`（可以选择，因为 `nums[0]` 已经使用过）。
     - 如果没有选择 `nums[0]`，直接选择 `nums[1]`，会被剪枝条件过滤。
   - **第3层递归：**
     - 选择 `nums[2] = 2`，递归。
3. **生成排列：**
   - `[1, 1, 2]` 是第一个排列。
   - 按照剪枝条件，确保不会再生成重复的 `[1, 1, 2]`。

------

### 总结：

- **`check[i] == true`**：避免重复选择已使用的数字。
- **`(i != 0 && nums[i] == nums[i - 1] && check[i - 1] == false)`**：避免生成重复排列，通过强制相同数字按顺序使用，保证排列唯一性。
- **排序 + 剪枝** 是解决 **全排列 II** 问题（有重复数字）的核心思想。





## 两种解法角度对比

代码示例中提到的两种方法都可以正确地解决 **力扣第 47 题「全排列 II」** 的问题，最终结果是一样的。两种方法的核心在于处理剪枝逻辑，分别是“只关心不合法的分支”和“只关心合法的分支”。

以下是对两种方法的分析：

------

### **方法 1：只关心“不合法”的分支**

#### 代码关键点：

```cpp
if (check[i] == true || (i != 0 && nums[i] == nums[i - 1] && check[i - 1] == false)) 
{
    continue;  // 跳过不合法的情况
}
```

- 逻辑：
  1. 如果当前数字已经使用过（`check[i] == true`），跳过。
  2. 如果当前数字和前一个数字相同（`nums[i] == nums[i - 1]`），且前一个数字还没被使用（`check[i - 1] == false`），跳过。
- 目的：
  - 条件 `(nums[i] == nums[i - 1] && check[i - 1] == false)` 用来避免重复排列。它确保相同的数字只能按照 **从左到右的顺序** 使用。
  - 例如，假设 `nums = [1, 1, 2]`，在生成排列时，只有前一个 `1` 被使用时，后一个 `1` 才能被选择。这样可以避免重复排列 `[1, 1, 2]`。

------

### **方法 2：只关心“合法”的分支**

#### 代码关键点：

```cpp
if (check[i] == false && (i == 0 || nums[i] != nums[i - 1] || check[i - 1] == true)) 
{
    // 处理合法的情况
}
```

- 逻辑：
  1. 如果当前数字未被使用（`check[i] == false`），且满足以下任一条件：
     - 当前数字是第一个数字（`i == 0`）。
     - 当前数字与前一个数字不同（`nums[i] != nums[i - 1]`）。
     - 当前数字与前一个数字相同，但前一个数字已经被使用过（`check[i - 1] == true`）。
- 目的：
  - 条件 `(check[i] == false && (i == 0 || nums[i] != nums[i - 1] || check[i - 1] == true))` 用来定义“合法”的选择。
  - 它确保 **在当前递归路径下，数字的选择顺序唯一**，同样可以避免重复排列。

------

### **两种方法的对比**

| **比较点**     | **方法 1（不合法分支）**                           | **方法 2（合法分支）**                         |
| -------------- | -------------------------------------------------- | ---------------------------------------------- |
| **核心思想**   | 剪掉所有“不合法”的分支，剩下的分支就是合法的       | 直接选择“合法”的分支                           |
| **实现方式**   | 用 `continue` 跳过不符合条件的分支                 | 用 `if` 语句直接判断是否是合法的分支           |
| **逻辑复杂度** | 条件相对直观，因为是针对“不合法”的条件进行剪枝     | 条件稍微复杂一些，因为需要明确定义“合法”的分支 |
| **是否正确**   | 正确                                               | 正确                                           |
| **性能差异**   | 两者性能基本相同，都是 O(n!)，具体效率依赖实现细节 | 性能基本相同，主要取决于剪枝逻辑是否严密       |

------

### **总结**

1. **两种方法都是正确的**，性能差异不大，主要看个人编程习惯。
   - 方法 1 的逻辑更偏向直接思考“不合法”的分支，排除掉这些分支即可。
   - 方法 2 更偏向关注“合法”的分支，直接明确哪些分支是可以选择的。
2. **推荐使用方法 2**：
   - 从实际开发经验来看，直接关注“合法”的分支逻辑更加清晰（因为它是选择条件）。
   - 它对代码的可读性和扩展性可能会更好。