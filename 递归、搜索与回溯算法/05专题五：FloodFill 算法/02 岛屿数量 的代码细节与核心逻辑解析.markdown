## 岛屿计数能不能在递归函数中更新，而不是在全局变量中更新？

是可以的，不过需要一些调整。`ret` 是用来记录岛屿数量的，而岛屿数量的增加是发生在每次发现一个新的岛屿时（即进入新的 `dfs` 的时候）。因此，在 `dfs` 函数中更新 `ret` 是可行的，但是要确保它只在递归的起点（即第一次调用 `dfs` 时）进行更新，不能在每一次递归调用中都增加。

下面是的代码是`ret` 在 `dfs` 函数中更新的实现方式：

### 修改代码

```cpp
class Solution
{
public:
    int ret;
    int dx[4] = { 0,0,1,-1 };
    int dy[4] = { 1,-1,0,0 };
    int n, m;
    vector<vector<bool>> vis;

    void dfs(vector<vector<char>>& grid, int i, int j, bool isNewIsland)
    {
        if (isNewIsland)
        {
            ret++;                           // 如果是新岛屿，增加计数
        }

        vis[i][j] = true;

        for (int k = 0; k < 4; k++)
        {
            int x = i + dx[k], y = j + dy[k];

            if (x >= 0 && x < n && y >= 0 && y < m && grid[x][y] == '1' && !vis[x][y])
            {
                dfs(grid, x, y, false);      // 后续递归不再更新岛屿计数
            }
        }
    }

    int numIslands(vector<vector<char>>& grid)
    {
        n = grid.size(), m = grid[0].size();
        vis = vector<vector<bool>>(n, vector<bool>(m));

        for (int i = 0; i < n; i++)
        {
            for (int j = 0; j < m; j++)
            {
                if (grid[i][j] == '1' && !vis[i][j])
                {
                    dfs(grid, i, j, true);  // 新岛屿时传入 true
                }
            }
        }

        return ret;
    }
};
```

### 修改的核心

1. 在 `dfs` 中引入一个布尔参数 `isNewIsland`，用于判断当前递归是否是一个新岛屿的起点。
2. 当 `dfs` 被首次调用时（即 `isNewIsland` 为 `true`），更新 `ret`，表示发现了一个新的岛屿。
3. 后续递归调用中，`isNewIsland` 传递为 `false`，避免重复增加岛屿计数。

### 为什么这样可以？

`dfs` 函数的职责是从当前格子开始，标记整个岛屿的所有格子为已访问。只有在调用 `dfs` 的入口（即某个格子第一次被标记为岛屿起点时），才会增加岛屿计数。通过布尔参数控制，可以精确区分递归的起点和递归的过程。

这样做使得岛屿计数的逻辑集中在 `dfs` 内部，调用逻辑更加简洁。
### 其正确性是正确的吗？

理论分析：在实际测试之前，首先要确保算法在理论上是正确的。

#### **算法流程**

1. **初始化**:
   - `ret` 被初始化为0，用于记录岛屿的数量。
   - `vis` 二维数组初始化为 `false`，表示所有格子都未被访问。
   - 遍历整个网格，每当遇到一个未被访问的 `'1'` 时，调用 `dfs` 并传入 `isNewIsland = true`。
2. **深度优先搜索（DFS）**:
   - 如果 `isNewIsland` 为 `true`，表示发现了一个新的岛屿，`ret` 增加1。
   - 标记当前格子为已访问。
   - 遍历四个方向（上下左右），对每个相邻的 `'1'` 且未被访问的格子递归调用 `dfs`，但这次传入 `isNewIsland = false`，确保只有最初的调用会增加 `ret`。

#### **正确性保障**

- **每个岛屿只计数一次**:
  - 只有在发现一个新的岛屿起点时（`isNewIsland = true`）才会增加 `ret`。
  - 同一岛屿内的其他格子在递归调用中被标记为访问过，不会再次增加 `ret`。
- **所有相连的陆地格子都被访问**:
  - 通过DFS，确保一个岛屿的所有相连陆地格子都被标记为已访问，避免遗漏。
- **避免重复计数**:
  - `vis` 数组确保每个格子只被访问一次，不会重复计数。

至于实际测试就这里就不过多赘述了，找几样测试用例即可。