//力扣：3. 无重复字符的最长子串
//https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/


//方法一：暴力枚举+哈希表（判断字符是否重复出现）
//时间复杂度：O(n^2)
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int ret = 0;                               // 用于存储最长无重复子串的长度

        // 外层循环，枚举子串的起点 i
        for (int i = 0; i < n; i++)
        {
            bool hash[128] = { false };            // 用大小为128的数组作为哈希表，记录每个字符是否出现过

            // 内层循环，扩展子串的终点 j
            for (int j = i; j < n; j++)
            {
                if (hash[s[j]])                    // 如果当前字符 s[j] 已经出现过，跳出循环
                {
                    break;                         // 结束当前子串的扩展
                }

                hash[s[j]] = true;                 // 否则，将当前字符标记为已出现
                ret = max(ret, j - i + 1);         // 更新最长子串长度
            }
        }

        return ret;                                // 返回最长无重复子串的长度
    }
};






//方法二：利用规律，使用“滑动窗口”来解决问题
//时间复杂度：O(n)

//算法原理：
//我们可以用一个哈希表来记录每个字符出现的次数。我们用两个指针 left 和 right 来表示当前窗口的左右边界。
//我们首先将 right 指针指向字符串的第一个字符，并将其加入窗口。然后我们开始移动 right 指针，
//如果当前字符 s[right] 已经出现在窗口中，我们就将 left 指针向右移动，直到窗口中没有重复的字符。
//然后我们将 right 指针向右移动，将新的字符加入窗口。我们重复这个过程，直到 right 指针到达字符串的末尾。
//此时，我们返回窗口的长度，即为最长无重复子串的长度。

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int hash[128] = { 0 };                      // 用大小为128的数组模拟哈希表，表示ASCII字符集。
        // 每个位置存储字符出现的次数，最多有128种可能的字符。

        int left = 0, right = 0, n = s.size();      // 初始化滑动窗口的左右边界和字符串长度。

        int ret = 0;                                // 用于存储最长无重复子串的长度。

        // 使用滑动窗口技术：right用于扩展窗口，left用于收缩窗口。
        while (right < n)                           // 右边界不断向右移动，直到遍历完整个字符串。
        {
            hash[s[right]]++;                       // 当前字符计数+1，表示字符s[right]进入窗口。

            // 如果当前字符s[right]的出现次数大于1，说明它在窗口中重复。
            while (hash[s[right]] > 1)              // 检查当前字符是否在窗口中重复。
            {
                hash[s[left]]--;                    // 如果重复，收缩窗口：左边界向右移动，并减少哈希表中s[left]的计数。
                left++;                             // 移动左边界，将窗口缩小以消除重复字符。
            }

            // 此时窗口中没有重复字符，更新最长子串长度。
            ret = max(ret, right - left + 1);       // right - left + 1 计算当前窗口中有效子串的长度。
            right++;                                // 右边界继续向右扩展，尝试找更长的无重复子串。
        }

        return ret;                                 // 返回找到的最长无重复子串的长度。
    }
};
//1. 哈希表的作用：
//通过 hash[128] 数组，我们可以记录每个字符出现的次数。数组大小是128，表示ASCII字符集（如a对应97，b对应98等），
//数组中每个元素存储对应字符出现的次数。初始时所有值为0，表示所有字符都未出现。

//2. 滑动窗口的概念：
//left 和 right 表示当前滑动窗口的左右边界。窗口中的字符是从left到right之间的所有字符。
//right 每次向右扩展窗口，将新的字符加入窗口；left在发现重复字符时移动以缩小窗口，直到窗口中的字符不再重复。

//3. 检测和处理重复字符：
//当新加入窗口的字符（s[right]）在窗口中已经存在（即哈希表中该字符的值大于1），就需要通过移动left来缩小窗口，
//去掉之前重复的字符，使窗口保持无重复字符的性质。

//4. 计算窗口内的有效子串长度：
//每当窗口内没有重复字符时，我们计算当前窗口的长度：right - left + 1。如果这个长度大于之前记录的最大值，就更新最大子串长度 ret。