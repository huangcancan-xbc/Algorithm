## BFS解决最短路问题_最短路问题简介

### **最短路问题简介**

最短路问题是图论中的经典问题之一，其目标是找到从一个起点（或多个起点）到一个终点（或多个终点）的**路径长度最短的路径**。路径长度可以是边的权值之和（加权图），也可以是路径中边的数量（无权图）。

------

### **最短路问题的分类**

1. **按图的边权值分类**：
   - **无权图**：图中的每条边的权值均为 1。  
     常用算法：**广度优先搜索（BFS）**。
   - **正权图**：图中所有边的权值均为非负数。  
     常用算法：**Dijkstra 算法**。
   - **有负权图**：图中允许存在负权边，但不能有负权回路（负权回路会导致路径长度无限减少）。  
     常用算法：**Bellman-Ford 算法** 或 **SPFA 算法**。
2. **按路径类型分类**：
   - **单源最短路**：给定图中的一个起点，求从该起点到所有其他节点的最短路径。  
     例如：从城市 A 到其他所有城市的最短路径。
   - **单源单点最短路**：给定图中的一个起点和一个终点，只求起点到终点的最短路径。  
     例如：从城市 A 到城市 B 的最短路径。
   - **多源最短路**：从多个起点出发，求所有起点到终点的最短路径。
   - **任意两点最短路**：求图中任意两点之间的最短路径。  
     常用算法：**Floyd-Warshall 算法**。
3. **按图的类型分类**：
   - **有向图**：图中边有方向，路径必须沿边的方向行走。
   - **无向图**：图中边无方向，路径可以双向通过。
   - **稀疏图**：边数较少（接近 `O(V)`），通常用邻接表表示。
   - **稠密图**：边数较多（接近 `O(V^2)`），通常用邻接矩阵表示。

------

### **常见最短路算法**

#### **1. 广度优先搜索（BFS）**

- 适用范围：**无权图**，即所有边权值均为 1。
- 原理：按层次遍历图，扩展的层数就是最短路径长度。
- 时间复杂度：`O(V + E)`。

#### **2. Dijkstra 算法**

- 适用范围：**正权图**。
- 原理：贪心算法，每次选择当前最短路径的未访问节点，更新其邻接点的距离。
- 时间复杂度：
  - 使用堆优化：`O((V + E) * log(V))`。
  - 使用数组：`O(V^2)`。

#### **3. Bellman-Ford 算法**

- 适用范围：**含负权边的图**，但不允许负权回路。
- 原理：迭代更新所有边的最短路径，最多进行 `V-1` 次迭代。
- 时间复杂度：`O(V * E)`。
- 优点：可以检测负权回路。

#### **4. SPFA（Shortest Path Faster Algorithm）**

- 适用范围：**含负权边的图**，但不允许负权回路。
- 原理：Bellman-Ford 的队列优化版本，仅对需要更新的节点进行松弛操作。
- 时间复杂度：最坏情况 `O(V * E)`，实际表现通常优于 Bellman-Ford。

#### **5. Floyd-Warshall 算法**

- 适用范围：**任意两点最短路**，可以处理负权边，但不允许负权回路。
- 原理：动态规划算法，通过逐步加入中间节点更新最短路径。
- 时间复杂度：`O(V^3)`。

#### **6. Johnson 算法**

- 适用范围：**任意两点最短路**，可以处理负权边，但不允许负权回路。
- 原理：通过对边权值重新标号，将负权图转为正权图，然后使用 Dijkstra 求解。
- 时间复杂度：`O(V^2 * log(V) + V * E)`。

最短路问题是图论和算法的基础问题，其不同的应用场景和图的特性决定了采用的算法不同。在实际问题中，选择合适的算法是解决问题的关键。在边权为 1 的最短路问题中，扩展的层数等于最短路的长度，原因与广度优先搜索（BFS）的特性有关。以下是具体的解释：

------

### **广度优先搜索（BFS）的核心特性**

1. **逐层扩展**：
   - BFS 是一种按层次遍历图的算法。在遍历时，先访问起点，然后依次访问与起点距离为 1 的所有节点，再访问距离为 2 的所有节点，依次类推。
   - 每一层代表从起点到这些节点的路径长度。
2. **无权图的最短路径保证**：
   - 如果图中的所有边权相等（例如都是 1），那么 BFS 的性质保证了：一个节点在首次被访问到时，从起点到该节点的路径就是最短路径。
   - 这是因为 BFS 是按层扩展的，它总是优先访问离起点较近的节点。

------

### **层数与最短路径的关系**

1. BFS 在扩展每一层时，会将与当前层相邻的节点加入队列，而这些节点的路径长度等于当前层数 + 1。
2. **起点到某个节点的最短路径长度，恰好等于该节点所在的层数**：
   - 层数是 BFS 中的一个自然属性，表示从起点出发需要跨越多少条边到达某一节点。
   - 如果边权全为 1，那么路径长度等于经过的边数，也等于 BFS 扩展的层数。

------

### **举例说明**

考虑一个无权图，其中边的权值均为 1：

```   mathematica
   A
 / | \
B  C  D
   |
   E
```

- 起点是 `A`。
- BFS 的扩展过程如下：
  1. 初始队列为 `A`，层数为 0。
  2. 第一层扩展：`B, C, D` 被访问，路径长度为 1（从 `A` 出发经过 1 条边）。
  3. 第二层扩展：`E` 被访问，路径长度为 2（从 `A` 出发经过 2 条边）。
- 因此，`B, C, D` 的最短路径长度为 1，而 `E` 的最短路径长度为 2，这正是 BFS 的层数。

------

### **为什么扩展的层数就是最短路径长度？**

1. **逐层推进**：
   - BFS 每次扩展一层，对应路径长度 +1，保证先访问到的节点一定是距离最近的。
2. **不回溯**：
   - BFS 访问一个节点时，不会再次访问已经访问过的节点，因此保证路径最短。
3. **所有边权均为 1**：
   - 路径长度仅依赖于边数，层数正好等于边数，因此层数等于路径长度。

------

### **总结**

扩展的层数就是最短路径的长度，因为 BFS 的按层扩展特性保证了在第一次访问到某个节点时，已经通过了最少的边数，而边权均为 1 时，最少的边数直接等于路径长度。