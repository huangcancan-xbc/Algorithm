### 解法一:

通过模拟手动逐位相乘并处理进位来得到结果。在处理大数乘法时，前导零的情况会被自动处理，原因如下：

### 1. **初始化和结果存储**

```cpp
vector<int> ret(len1 + len2, 0); // 构建结果数组，大小为 num1 长度 + num2 长度
```

- `ret` 用于存储乘法结果的每一位，长度为 `len1 + len2`，其中 `len1` 和 `len2` 分别是 `num1` 和 `num2` 的长度。
- 即使 `num1` 或 `num2` 包含前导零，`ret` 数组也会有足够的空间来存储结果。

### 2. **逐位相乘和进位**

在这段代码中，内外层循环模拟了两个数的逐位相乘：

```cpp
for (int i = len1 - 1; i >= 0; i--) 
{
    for (int j = len2 - 1; j >= 0; j--) 
    {
        int cur = (num2[j] - '0') * (num1[i] - '0');      // 计算当前位的乘积
        int sum = cur + ret[i + j + 1];                   // 计算当前位的和
        ret[i + j + 1] = sum % 10;                        // 当当前位的和大于9时，需要进位
        ret[i + j] += sum / 10;                           // 进位的位置
    }
}
```

- `cur` 表示两个数字的当前位相乘得到的乘积。
- `sum` 是当前位的乘积与之前存储在 `ret` 中的值相加的结果。
- 在这部分，代码会处理进位和个位数的存储。

### 3. **处理前导零**

在构造最终结果字符串时，代码如下：

```cpp
string ans;
for (auto x : ret) 
{
    if (!(ans.empty() && x == 0)) // 如果结果字符串为空且当前位不为0
    {  
        ans.push_back(x + '0');
    }
}
```

- 这个部分的关键是判断是否忽略前导零。`ans.empty()` 确保只有在第一次遇到非零值时才将数字加入 `ans` 字符串中，从而避免前导零的出现。
- 如果 `ret` 数组中的某一位是 `0` 且 `ans` 字符串为空，说明这是一个前导零，代码会跳过该位。
- 这样，前导零会被自动忽略，不会出现在最终的结果中。

### 4. **最终的返回值**

```cpp
return ans.empty() ? "0" : ans;  // 如果结果字符串为空，则返回"0"
```

- 如果 `ans` 为空（即两个数都为 "0"），返回 "0"。
- 这也保证了，即使输入包含多个零或空字符串（比如 "000" 或 "0"），输出会是 "0" 而不是空字符串。

### 总结

这段代码已经很好地处理了前导零的情况。它的工作原理如下：

- 在计算过程中，乘法结果会被逐位存储，并且只有在遇到非零的位时才会将其加入结果字符串。
- 如果最终结果是零（例如 "000" 或 "0"），会返回 "0" 而不是空字符串。







### 在解法二中，

`temp[i + j] += (num1[i] - '0') * (num2[j] - '0');` 不能直接使用 `=`，原因是这里的 `temp[i + j]` 是存储部分乘积结果的数组，它已经包含了之前的计算结果。在进行逐位乘法时，我们需要累加每一位的乘积，而不是覆盖它。

### 详细解释：

1. **逐位乘法的累加**：
   - `temp[i + j]` 代表的是第 `i + j` 位的累加和。每次计算 `num1[i] * num2[j]`，我们将其加到 `temp[i + j]`，而不是直接赋值给它。
   - 这样做的原因是，计算过程中不同的位可能会对同一位产生贡献。例如，`num1[0] * num2[1]` 和 `num1[1] * num2[0]` 都会对 `temp[1]` 产生影响。所以我们需要通过加法累加这些部分乘积。
2. **举个简单的例子**：
   - 假设 `num1 = "12"`和 `num2 = "34"`，我们逐位乘法的过程如下：
     - `num1[0] * num2[0] = 1 * 3 = 3`，这个结果会被存储在 `temp[0]` 中。
     - `num1[0] * num2[1] = 1 * 4 = 4`，这个结果会加到 `temp[1]`。
     - `num1[1] * num2[0] = 2 * 3 = 6`，这个结果也会加到 `temp[1]`，因此 `temp[1]` 会变成 `4 + 6 = 10`。
     - `num1[1] * num2[1] = 2 * 4 = 8`，这个结果会被存储在 `temp[2]` 中。
   - 结果的 `temp` 数组内容会是：`[3, 10, 8]`，即 `3`、`10` 和 `8` 分别对应乘积结果的不同位。
3. **进位的处理**：
   - 在累加部分乘积的过程中，我们有可能产生大于 `9` 的数值。例如，在上面的例子中，`temp[1]` 最终会变成 `10`，这就意味着有一个进位。这个进位将在后续的处理步骤中通过 `sum` 进行处理。

### 如果使用 `=` 会发生什么：

如果直接用 `temp[i + j] = (num1[i] - '0') * (num2[j] - '0');`，则每次计算时，`temp[i + j]` 会被覆盖，导致无法累加之前的部分乘积。这就会破坏乘法结果。

### 总结：

- **`+=`** 用于在每个位置累加部分乘积，以确保正确合并所有位的乘积结果。
- **`=`** 会直接覆盖当前的值，无法实现累加逻辑，导致最终结果不正确。







为了更好地理解这两种方法，我们可以通过一个简单的示例来模拟它们的工作流程。假设我们需要计算字符串 `"123"` 和 `"456"` 的乘积。

### 示例：计算 "123" * "456"

------

#### 方法一：模拟竖式乘法

算法通过模拟小学列竖式计算两个数相乘的过程来实现。步骤如下：

1. **初始化**：

   - 输入：`num1 = "123"`, `num2 = "456"`
   - 计算它们的长度：`len1 = 3`, `len2 = 3`
   - 初始化一个 `ret` 数组，长度为 `len1 + len2 = 6`，所有元素初始化为0，表示结果数组。

   ```
   ret = [0, 0, 0, 0, 0, 0]
   ```

2. **逆序遍历 num1 和 num2**：

   - 从 `num1` 和 `num2` 的最后一位开始计算它们的乘积，并把结果累加到 `ret` 数组中。

   **第一步**：`num1[2] = '3'`，`num2[2] = '6'`：

   - `cur = 3 * 6 = 18`
   - `sum = 18 + ret[5] = 18`，更新 `ret[5] = 18 % 10 = 8`，`ret[4] += 18 / 10 = 1`

   ```
   ret = [0, 0, 0, 0, 1, 8]
   ```

   **第二步**：`num1[2] = '3'`，`num2[1] = '5'`：

   - `cur = 3 * 5 = 15`
   - `sum = 15 + ret[4] = 16`，更新 `ret[4] = 16 % 10 = 6`，`ret[3] += 16 / 10 = 1`

   ```
   ret = [0, 0, 0, 1, 6, 8]
   ```

   **第三步**：`num1[2] = '3'`，`num2[0] = '4'`：

   - `cur = 3 * 4 = 12`
   - `sum = 12 + ret[3] = 13`，更新 `ret[3] = 13 % 10 = 3`，`ret[2] += 13 / 10 = 1`

   ```
   ret = [0, 0, 1, 3, 6, 8]
   ```

   重复此过程直到所有位计算完毕，最终得到 `ret = [0, 5, 6, 0, 8, 8]`。

3. **构造最终结果**：

   - 从 `ret` 数组中获取非零的结果并将其转为字符串：`"56088"`。

------

#### 方法二：无进位相乘，再相加，最后处理进位

这个方法先进行逐位相乘，并累加结果，然后再处理进位，最终得到结果。

1. **初始化**：

   - 输入：`num1 = "123"`, `num2 = "456"`
   - 反转字符串：`num1 = "321"`, `num2 = "654"`
   - 初始化一个 `temp` 数组，长度为 `num1.size() + num2.size() = 6`，所有元素初始化为0。

   ```
   temp = [0, 0, 0, 0, 0, 0]
   ```

2. **无进位相乘**：

   - 遍历 `num1` 和 `num2` 的每一位，进行逐位相乘并累加到 `temp` 数组中。

   **第一步**：`num1[0] = '3'`，`num2[0] = '6'`：

   - `temp[0] += 3 * 6 = 18`

   ```
   temp = [18, 0, 0, 0, 0, 0]
   ```

   **第二步**：`num1[0] = '3'`，`num2[1] = '5'`：

   - `temp[1] += 3 * 5 = 15`

   ```
   temp = [18, 15, 0, 0, 0, 0]
   ```

   **第三步**：`num1[0] = '3'`，`num2[2] = '4'`：

   - `temp[2] += 3 * 4 = 12`

   ```
   temp = [18, 15, 12, 0, 0, 0]
   ```

   重复此过程直到所有位计算完毕，最终得到 `temp = [18, 30, 24, 6, 0, 0]`。

3. **处理进位**：

   - 从 `temp` 数组开始处理进位。
   - `sum = 18 % 10 = 8`，`sum / 10 = 1`，更新进位。
   - 重复此过程直到 `temp` 中的所有元素处理完毕。

   最终得到 `ret = "56088"`。

------

### 比较两种方法：

1. **方法一**：
   - **优点**：直接模拟竖式乘法，适合手动理解，步步清晰。
   - **缺点**：需要额外的空间来存储结果数组，且乘法计算量较大，时间复杂度为 O(n * m)，其中 n 和 m 分别是两个字符串的长度。
2. **方法二**：
   - **优点**：通过先计算乘积，再处理进位，优化了代码结构，计算过程更加简洁。
   - **缺点**：依赖字符串反转，稍微增加了代码复杂性。

两者的最终结果都是 `"56088"`，因此它们是等效的。