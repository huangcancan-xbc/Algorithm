//力扣：202. 快乐数
//https://leetcode.cn/problems/happy-number/description/

//算法原理：
//可联想《判断链表是否有环》进行扩展
//解法：快慢双指针法
//1.定义快慢指针
//2.快指针每次走一步，慢指针每次走两步
//3.判断相遇时的值即可
//注意：这里的快慢指针并不是传统意义上的快慢指针，既区分与数组下标，又区分与指针变量。
// *此处实际上是指一个数值序列，每一步计算的结果就是序列中的下一个数值。即：直接将数字作为指针变量，而非数组下标。*


//同时也是鸽巢原理（Pigeonhole Principle）（抽屉原理）的应用
//鸽巢原理简单来说就是：如果有 n 只鸽子要放入少于 n 个鸽巢里，那么至少有一个鸽巢里会有不止一只鸽子。
//在数学上，它通常用来说明在一个有限空间里，某些元素必须重复出现。

//快乐数的检测：
//在检测一个数是否是快乐数时，我们会不断地计算数字各个位的平方和，形成一个新的数字，继续重复这个过程。
//根据算法，快乐数最终会收敛到 1，而非快乐数会进入一个循环，不再变化。

//问题在于：我们怎么知道它会不会进入一个循环？这就是鸽巢原理的应用。让我们分析一下：
//        *数字在不断转换过程中，不可能无限制地增长（因为每次转换都会减少数字位数的值）。最终所有数字都会进入一个有限的范围。
//        因为9的平方是其他数字的平方之和最大的，所以用9的平方作为起点，用9999999999为例（超出int范围，可以放心他足够大），
//        他的平方和为810，所以不管数字有多少位，只要它的各位最大数为 9，它的平方和的上限就是 81 × 位数。
//        一般来说，通过计算各位数的平方和，数字会迅速减少，最终会进入一个较小的范围。
//
//        *因为这个范围是有限的（即“鸽巢”是有限的），如果我们无限次地进行数字变化操作（相当于“鸽子”），那么必定会有一个数字重复出现，形成循环。


//结论：
//即使输入的数字非常大，比如 9999999999，经过每一位的平方和计算，它的值很快会降到 810。从 810 开始，数字将逐步减少，
//直到最终进入一个有限的循环或者收敛到 1（如果它是快乐数）。这就是为什么数字在不断转换过程中不会无限制地增长，而是最终会进入一个有限的范围。
//
//这也解释了鸽巢原理的应用：无限制的转换操作只能在有限的数字范围内进行，因此数字要么收敛到 1，要么进入循环。
class Solution {
public:
    // 计算每个数位的平方和
    int square(int n)
    {
        int sum = 0;
        while (n)
        {
            int x = n % 10;        // 取出当前数字的最后一位
            sum += x * x;          // 计算该位数字的平方，并累加到sum
            n /= 10;               // 去掉最低位，继续处理
        }

        return sum;                // 返回所有数字平方的和
    }

    // 判断一个数是否是快乐数
    bool isHappy(int n)
    {
        int slow = n, fast = square(n);  // fast先走一步 (square(n))实现“追赶”

        // 快慢指针法：如果没有循环，slow最终会变为1。巧妙地利用了:1的平方和为1，不存在循环。
        while (slow != fast)
        {
            slow = square(slow);         // 慢指针 slow 每次走一步（平方一次）
            fast = square(square(fast)); // 快指针 fast 每次走两步（平方两次）
        }

        // 判断是否是快乐数：如果slow等于1则返回true
        return slow == 1;
    }
};
