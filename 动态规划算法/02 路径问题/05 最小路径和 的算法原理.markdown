## 算法原理

### 1. 状态表示
对于这种路径类的问题，我们的状态表示一般有两种形式：
- 从 `[i, j]` 位置出发，进行某种操作；
- 从起始位置出发，到达 `[i, j]` 位置，进行某种操作。

这里选择第二种定义状态表示的方式：
- `dp[i][j]` 表示：从起点 `(0, 0)` 到达 `(i, j)` 位置的最小路径和。

### 2. 状态转移方程
到达 `(i, j)` 位置的最小路径和可以通过以下两种方式得到：
- 从 `(i-1, j)` 向下走一步到达 `(i, j)`；
- 从 `(i, j-1)` 向右走一步到达 `(i, j)`。

因此，状态转移方程为：$dp[i][j] = \min(dp[i-1][j], dp[i][j-1]) + grid[i][j]$

### 3. 初始化

为了简化边界条件的处理，可以在网格的最前面添加一个辅助行和辅助列，并将这些辅助位置的值初始化为无穷大（表示无效值）。然后，将 `dp[0][1]` 和 `dp[1][0]` 初始化为 `0`，因为从起点到起点的路径和为 `0`。

### 4. 填表顺序
根据状态转移方程，填表的顺序是从上到下、从左到右。即先填完第一行，再填第二行，依此类推。

### 5. 返回值

根据状态表示，最终的结果是 `dp[n][m]`，即从起点 `(0, 0)` 到达终点 `(n-1, m-1)` 的最小路径和。
