## 算法原理

### 1. 状态表示

这道题如果我们定义成：从起点开始，到达 `[i, j]` 位置的时候，所需的最低初始健康点数。那么我们分析状态转移的时候会有一个问题：那就是我们当前的健康点数还会受到后面路径的影响。也就是说，从上往下的状态转移不能很好地解决问题。

这个时候我们要换一种状态表示：**从 `[i, j]` 位置出发，到达终点时所需要的最低初始健康点数**。这样我们在分析状态转移的时候，后续的最佳状态就已经知晓。

综上所述，定义状态表示为：

`dp[i][j]` 表示：从 `[i, j]` 位置出发，到达终点时所需的最低初始健康点数。

### 2. 状态转移方程

对于 `dp[i][j]`，从 `[i, j]` 位置出发，下一步会有两种选择（为了方便理解，设 `dp[i][j]` 的最终答案是 `x`）：

- **走到右边，然后走向终点**
  
  那么我们在 `[i, j]` 位置的最低健康点数加上这个位置的消耗，应该要大于等于右边位置的最低健康点数，也就是： $x + dungeon[i][j] >= dp[i][j + 1]$，通过移项可得：$x = dp[i][j + 1] - dungeon[i][j]$。

- **走到下边，然后走向终点**
  
  那么我们在 `[i, j]` 位置的最低健康点数加上这个位置的消耗，应该要大于等于下边位置的最低健康点数，也就是：$x + dungeon[i][j] >= dp[i + 1][j]$，通过移项可得：$x = dp[i + 1][j] - dungeon[i][j]$。

综上所述，我们需要的是两种情况下的最小值，因此可得状态转移方程为：$dp[i][j] = min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]$

但是，如果当前位置的 `dungeon[i][j]` 是一个比较大的正数的话，`dp[i][j]` 的值可能会变成0或者负数。也就是说，最低点数会小于1，那么骑士就会死亡。因此我们求出来的 `dp[i][j]` 如果小于等于0的话，说明此时的最低初始值应该为1。处理这种情况仅需让 `dp[i][j]` 与1取一个最大值即可：$dp[i][j] = max(1, dp[i][j])$

### 3. 初始化

可以在最前面加上一个“辅助结点”，帮助我们初始化。使用这种技巧要注意两个点：

- 辅助结点里面的值要“保证后续填表是正确的”；
- “下标的映射关系”。

在本题中，在 `dp` 表最后面添加一行，并且添加一列后，所有的值都先初始化为无穷大，然后让 `dp[m][n - 1] = dp[m - 1][n] = 1` 即可。

### 4. 填表顺序

根据“状态转移方程”，我们需要“从下往上填每一行”，“每一行从右往左”。

### 5. 返回值

根据“状态表示”，我们需要返回 `dp[0][0]` 的值。

---

### 1. 为什么不能以“从起点出发，逐步推进”来做？

#### 问题分析

- **路径选择的不确定性**：
  - 从起点 `(0, 0)` 出发，每一步的选择（向右或向下）会影响后续的血量变化。然而，我们无法提前知道哪条路径是最优的，因为后续的血量变化是未知的。
  - 例如，假设从 `(0, 0)` 出发，向右走可能会导致某个位置的血量过低，而向下走可能会遇到更困难的局面。这种不确定性使得我们无法通过从起点出发的方式推导出全局最优解。

- **最小生命值的递推关系问题**：
  - 从起点出发，每一步的血量变化会影响后续的选择。如果我们直接从起点计算，可能会遇到某些位置的血量为负数，导致无法继续前进。
  - 例如，假设从 `(0, 0)` 出发，向右走一步后血量变为负数，那么这条路径就是无效的。然而，我们无法提前知道哪些路径是有效的，因此无法通过从起点出发的方式推导出最小初始生命值。

#### 具体例子

假设地下城如下：
```
dungeon = [
  [-2, -3,  3],
  [-5, -10, 1],
  [10, 30, -5]
]
```
- 如果从起点 `(0, 0)` 出发，向右走一步，血量变为 `-2`，此时血量已经为负数，无法继续前进。
- 如果向下走一步，血量变为 `-5`，同样无法继续前进。
- 因此，从起点出发的方式无法推导出最小初始生命值。

---

### 2. 为什么从终点反向推导可以解决问题？

#### 问题分析

- **状态转移方程的确定性**：
  - 从终点 `(n-1, m-1)` 出发，我们知道目标位置的生命值必须至少为 1。因此，反向计算时，每个位置的最小生命值可以通过其相邻位置（右边或下边）的最小生命值来推导。
  - 通过 `dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]`，我们能够确保每个位置的生命值满足从目标到该位置的最小要求。

- **递推的简洁性**：
  - 从终点出发，每个位置的最小生命值只依赖于其右边和下边的位置，因此递推的方式非常简单。
  - 由于从终点到起点的计算是完全确定的，递推的方式不会因为路径选择不同而发生变化。

#### 具体例子

继续以上述地下城为例：
```
dungeon = [
  [-2, -3,  3],
  [-5, -10, 1],
  [10, 30, -5]
]
```
- 从终点 `(2, 2)` 出发，初始 `dp[2][2] = max(1, 1 - (-5)) = 6`。
- 递推到 `(2, 1)`，`dp[2][1] = max(1, 6 - 30) = 1`。
- 递推到 `(2, 0)`，`dp[2][0] = max(1, 1 - 10) = 1`。
- 递推到 `(1, 2)`，`dp[1][2] = max(1, 6 - 1) = 5`。
- 递推到 `(1, 1)`，`dp[1][1] = max(1, min(5, 1) - (-10)) = 11`。
- 递推到 `(1, 0)`，`dp[1][0] = max(1, min(1, 11) - (-5)) = 6`。
- 递推到 `(0, 2)`，`dp[0][2] = max(1, 5 - 3) = 2`。
- 递推到 `(0, 1)`，`dp[0][1] = max(1, min(2, 11) - (-3)) = 5`。
- 递推到 `(0, 0)`，`dp[0][0] = max(1, min(6, 5) - (-2)) = 7`。

最终，从起点 `(0, 0)` 出发所需的最小生命值为 `7`。

---

### 3. 小结

#### 为什么不能从起点出发：

- 从起点出发的方式无法提前知道路径选择的最优解，且无法处理路径中可能出现的负血量问题。
- 由于路径选择的不确定性，无法通过从起点出发的方式推导出最小初始生命值。

#### 为什么从终点出发可以解决问题：

- 从终点出发的方式能够通过递推的方式，确保每个位置的最小生命值满足从目标到该位置的最小要求。
- 递推的方式简单且确定，能够避免路径选择带来的不确定性。

