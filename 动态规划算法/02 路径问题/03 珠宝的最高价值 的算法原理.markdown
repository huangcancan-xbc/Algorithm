## 算法原理

### 1. 状态表示

对于这种“路径类”的问题，我们的状态表示一般有两种形式：
- i. 从 `[i, j]` 位置出发；
- ii. 从起始位置出发，到达 `[i, j]` 位置。

这里选择第二种定义状态表示的方式：

`dp[i][j]` 表示：走到 `[i, j]` 位置处，此时的最大价值。

### 2. 状态转移方程

对于 `dp[i][j]`，我们发现想要到达 `[i, j]` 位置，有两种方式：
- i. 从 `[i, j]` 位置的上方 `[i - 1, j]` 位置向下走一步，此时到达 `[i, j]` 位置能拿到的礼物价值为 `dp[i - 1][j] + grid[i][j]`；
- ii. 从 `[i, j]` 位置的左边 `[i, j - 1]` 位置向右走一步，此时到达 `[i, j]` 位置能拿到的礼物价值为 `dp[i][j - 1] + grid[i][j]`。

我们要的是最大值，因此状态转移方程为：$dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]$

### 3. 初始化

可以在最前面加上一个“辅助结点”，帮助我们初始化。使用这种技巧要注意两个点：
- i. 辅助结点里面的值要“保证后续填表是正确的”；
- ii. “下标的映射关系”。

在本题中，“添加一行”，并且“添加一列”后，所有的值都为 0 即可。

### 4. 填表顺序

根据“状态转移方程”，填表的顺序是“从上往下填写每一行”，“每一行从左往右”。

### 5. 返回值

根据“状态表示”，我们应该返回 `dp[m][n]` 的值。

