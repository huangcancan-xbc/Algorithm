## 算法原理

关于这一类题，由于我们做过类似的，因此“状态表示”以及“状态转移”是比较容易分析出来的。比较难的地方可能就是对于“边界条件”的处理。

### 1. 状态表示

对于这种“路径类”的问题，我们的状态表示一般有两种形式：
- i. 从 `[i, j]` 位置出发，到达目标位置有多少种方式；
- ii. 从起始位置出发，到达 `[i, j]` 位置，一共有多少种方式。

这里选择第二种定义状态表示的方式：

`dp[i][j]` 表示：到达 `[i, j]` 位置时，所有下降路径中的最小和。

### 2. 状态转移方程

对于普遍位置 `[i, j]`，根据题意得，到达 `[i, j]` 位置可能有三种情况：
- i. 从正上方 `[i - 1, j]` 位置转移到 `[i, j]` 位置；
- ii. 从左上方 `[i - 1, j - 1]` 位置转移到 `[i, j]` 位置；
- iii. 从右上方 `[i - 1, j + 1]` 位置转移到 `[i, j]` 位置。

我们要的是三种情况下的“最小值”，然后再加上矩阵在 `[i, j]` 位置的值。于是状态转移方程为：$dp[i][j] = min(dp[i - 1][j], min(dp[i - 1][j - 1], dp[i - 1][j + 1])) + matrix[i][j]$

### 3. 初始化

可以在最前面加上一个“辅助结点”，帮助我们初始化。使用这种技巧要注意两个点：
- i. 辅助结点里面的值要“保证后续填表是正确的”；
- ii. “下标的映射关系”。

在本题中，需要“加上一行”，并且“加上两列”。所有的位置都初始化为无穷大，然后将第一行初始化为 0 即可。

### 4. 填表顺序

根据“状态表示”，填表的顺序是“从上往下”。

### 5. 返回值

注意这里不是返回 `dp[m][n]` 的值！题目要求“只要到达最后一行”就行了，因此这里应该返回“`dp` 表中最后一行的最小值”。
