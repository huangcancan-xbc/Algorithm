### 算法思路

**问题描述**：给定一个整数 `n`，求由 `n` 个节点组成的二叉搜索树（BST）有多少种不同的结构。

这道题属于「卡特兰数」的一个应用，同样能解决的问题还有「合法的进出栈序列」、「括号匹配的括号序列」、「电影购票」等等。

![image-20250306175612657](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250306175612807.png)

---

#### 1. 状态表示

这道题的状态表示就是根据「拆分出相同子问题」的方式，抽象出来一个状态表示：
- 当我们在求个数为 n 的 BST（二叉搜索树）的个数的时候，当确定一个根节点之后，左右子树的结点「个数」也确定了。
- 此时左右子树就会变成相同的子问题，因此我们可以这样定义状态表示：
    - `dp[i]` 表示：当结点的数量为 i 个的时候，一共有多少颗 BST（**核心思想**：通过动态规划将问题分解为子问题，利用二叉搜索树的结构特性（根节点划分左右子树）递推求解）。


#### 2. 状态转移方程

对于 `dp[i]`，此时我们已经有 i 个结点了，为了方便叙述，我们将这 i 个结点排好序，并且编上 1, 2, 3, 4, 5.....i 的编号。那么，对于所有不同的 BST，我们可以按照下面的划分规则，分成不同的 i 类：「按照不同的头结点来分类」。

- 分类结果就是：
  - 头结点为 1 号结点的所有 BST；
  - 头结点为 2 号结点的所有 BST；
  - ......
  

如果我们能求出「每一类中的 BST 的数量」，将所有类的 BST 数量累加在一起，就是最后结果。

接下来选择「头结点为 j 号」的结点，来分析这 i 类 BST 的通用求法：

- 如果选择「j 号结点来作为头结点」，根据 BST 的定义：
  - j 号结点的「左子树」的结点编号应该在 `[1, j - 1]` 之间，一共有 `j - 1` 个结点。那么 `j` 号结点作为头结点的话，它的「左子树的种类」就有 `dp[j - 1]` 种；
  - j 号结点的「右子树」的结点编号应该在 `[j + 1, i]` 之间，一共有 `i - j` 个结点。那么 `j` 号结点作为头结点的话，它的「右子树的种类」就有 `dp[i - j]` 种；
  

根据「排列组合」的原理可得：`j` 号结点作为头结点的 BST 的种类一共有 `dp[j - 1] * dp[i - j]` 种！

因此，我们只要把「不同头结点的 BST 数量」累加在一起，就能得到 `dp[i]` 的值：`dp[i] += dp[j - 1] * dp[i - j] (1 <= j <= i)`。「注意用的是 += ，并且 j 从 1 变化到 i」。

#### 3. 初始化

我们注意到，每一个状态转移里面的 `j - 1` 和 `i - j` 都是小于 `i` 的，并且可能会用到前一个的状态（当 i = 1，j = 1 的时候，要用到 `dp[0]` 的数据）。因此要先把第一个元素初始化。

当 i = 0 的时候，表示一颗空树，「空树也是一颗二叉搜索树」，因此 `dp[0] = 1`。其他情况：`dp[i > 0]` 初始化为 0，表示初始状态下无法组成 BST。

#### 4. 填表顺序

根据「状态转移方程」，易得「从左往右」。

#### 5. 返回值

根据「状态表示」，我们要返回的是 `dp[n]` 的值。

#### 6. 关键点

- **BST 的结构特性**：
    - 节点的值唯一且有序，结构数目仅与节点数量有关，与具体数值无关。
    - 根节点将序列划分为左子树（更小的值）和右子树（更大的值），形成递归子问题。
- **卡特兰数**：此问题的解是卡特兰数的第 `n` 项，递推公式与卡特兰数的定义一致。