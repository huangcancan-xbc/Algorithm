### 算法原理详解

#### 1. 状态表示  
**定义**：`dp[i][j]` 表示将子字符串 `s[i...j]` 转换为回文串所需的最少插入次数。
**含义**：  

- 当 `i == j` 时，子串长度为 1，本身是回文，无需插入（`dp[i][j] = 0`）。  
- 当 `i < j` 时，通过比较 `s[i]` 和 `s[j]` 的关系，递归计算最小插入次数。

#### 2. 状态转移方程

![image-20250226172416641](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250226172525910.png)

根据子串两端字符是否相等，分两种情况：

- **情况 1：`s[i] == s[j]`**
  两端字符相同，中间部分的最优解可直接继承：  
  
  ```  c++
  dp[i][j] = dp[i+1][j-1]  
  ```
  解释：  
  - 若 `i + 1 < j`（中间有其他字符），直接取中间子串 `s[i+1...j-1]` 的最优解。  
  - 若 `i + 1 == j`（相邻字符），中间无字符，无需插入（`dp[i][j] = 0`）。
  
- **情况 2：`s[i] != s[j]`**  
  两端字符不同，需插入字符使两端相等。有两种选择：  
  1. 在左侧插入 `s[j]`，使 `s[i...j]` 变为 `s[j] + s[i...j]`，对应子问题 `dp[i][j-1] + 1`。  
  2. 在右侧插入 `s[i]`，使 `s[i...j]` 变为 `s[i...j] + s[i]`，对应子问题 `dp[i+1][j] + 1`。  
  取两者最小值：  
  ```  c++
  dp[i][j] = min(dp[i+1][j] + 1, dp[i][j-1] + 1)
  // 等价：dp[i][j] = min(dp[i+1][j], dp[i][j-1]) + 1
  ```

#### 3. 初始化

- **基础情况**：所有长度为 1 的子串初始化为 0：  
  
  ```  
  dp[i][i] = 0   // 单个字符无需插入  
  ```
- **其他情况**：初始时 `dp[i][j]` 为 0，后续通过状态转移填充。

#### 4. 填表顺序

- **外层循环**：`i` 从 `n-1` 到 `0`（从后往前遍历起始点）。  
- **内层循环**：`j` 从 `i+1` 到 `n-1`（处理所有以 `i` 开头、长度 ≥2 的子串）。  
**目的**：确保计算 `dp[i][j]` 时，其依赖的子问题 `dp[i+1][j-1]`、`dp[i+1][j]`、`dp[i][j-1]` 已被计算。

#### 5. 返回值

最终返回 `dp[0][n-1]`，表示将整个字符串 `s[0...n-1]` 变为回文所需的最小插入次数。

#### 复杂度

- **时间复杂度**：O(n²)，需遍历所有子串。  
- **空间复杂度**：O(n²)，存储 `dp` 表。