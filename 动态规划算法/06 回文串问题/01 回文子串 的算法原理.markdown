### 算法原理

1. **定义状态**：`dp[i][j]` 表示子串 `s[i..j]` 是否为回文子串。  
   
   - 当 `s[i] == s[j]` 时，若其内部子串 `s[i+1..j-1]` 是回文，则 `s[i..j]` 也是回文。
   - 特殊情况处理：当子串长度为 1（`i == j`）或 2（`j = i+1` 且字符相同）时，直接视为回文。

2. **状态转移方程**  
   - 若 `s[i] != s[j]`，则 `dp[i][j] = false`。
   - 若 `s[i] == s[j]`：
     - 当子串长度 ≤ 2（即 `j - i < 2`），`dp[i][j] = true`。
     - 否则，`dp[i][j] = dp[i+1][j-1]`（内部子串是否为回文）。

   ![image-20250225001244749](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/image-20250225001244749.png)
   
3. **遍历顺序** —— 确保所有依赖的子状态已提前计算
   - **从后向前** 遍历起始点 `i`，确保在计算 `dp[i][j]` 时，`dp[i+1][j-1]` 已计算完成。
   - **从前向后** 遍历结束点 `j`（从 `i` 开始），覆盖所有以 `i` 开头的子串。

#### 关键步骤

- **初始化**：二维数组 `dp` 初始为 `false`。
- **填表与统计**：遍历过程中，若 `dp[i][j]` 为 `true`，则计数器 `ret` 自增，最终返回 `ret`。

#### 复杂度分析

- **时间复杂度**：O(n²)，双重循环遍历所有子串。
- **空间复杂度**：O(n²)，存储动态规划表。
