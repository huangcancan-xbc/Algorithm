### 算法原理

1. **状态表示**
   定义二维数组 `dp[i][j]`，表示字符串 `s` 的子串 `s[i...j]` 是否为回文子串。若 `dp[i][j] = true`，则该子串是回文；否则不是。

2. **状态转移方程**

   - 当 `s[i] != s[j]` 时，`dp[i][j] = false`（首尾字符不同，显然不是回文）。
   - 当 `s[i] == s[j]` 时，需根据内部子串判断：
     - 若子串长度 ≤ 2（即 `j - i < 2`），则 `dp[i][j] = true`（如单字符或相邻相同字符）。
     - 否则，`dp[i][j] = dp[i+1][j-1]`（内部子串是否为回文决定当前子串是否为回文）。
     综合为：  
   ```cpp
   dp[i][j] = (s[i] == s[j]) && (j - i < 2 || dp[i+1][j-1]);
   ```

3. **初始化**
   所有长度为 1 的子串均为回文，即 `dp[i][i] = true`。其他情况初始为 `false`，在动态规划过程中填充。

4. **填表顺序**
   外层循环 `i` 从后向前遍历（确保处理 `i` 时 `i+1` 行的数据已计算），内层循环 `j` 从 `i` 向后遍历，确保 `dp[i][j]` 依赖的 `dp[i+1][j-1]` 已被计算。

   >#### 填表顺序的深层解析
   >
   >**1. 为什么必须从下往上填表？**
   >
   >- **依赖关系**：判断 `dp[i][j]` 是否为回文时，需要先知道 `dp[i+1][j-1]` 的值。
   >- **顺序保证**：当外层循环 `i` 从 `n-1` 递减到 `0` 时，`i+1` 行的数据已经全部计算完毕。  
   >    **示例**：假设当前计算 `i=2`，此时 `i+1=3` 行的所有 `j` 值已处理完毕，因此 `dp[3][...]` 的数据是可靠的。
   >
   >**2. 内层循环 j 为何从 i 开始递增？**
   >
   >- **子串长度控制**：`j` 从 `i` 开始递增，保证了子串长度 `j-i+1` 从 1 逐步增加到 `n-i`。
   >- **短到长判断**：先处理短子串（如单字符、双字符），再处理长子串，确保内部子串 `s[i+1..j-1]` 已被判断。  
   >    **示例**：当判断 `s[0..4]` 时，需要 `s[1..3]` 的结果，而 `s[1..3]` `s[1..2]` 等更短的子串已在之前步骤处理。
   >
   >**3. 填表顺序的可视化说明**
   >
   >以字符串 `s = "abcba"` 为例（索引 0~4）：
   >
   >| i\j  |  0   |  1   |  2   |  3   |  4   |
   >| :--: | :--: | :--: | :--: | :--: | :--: |
   >|  4   |  -   |  -   |  -   |  -   | true |
   >|  3   |  -   |  -   |  -   | true | ...  |
   >|  2   |  -   |  -   | true | ...  | ...  |
   >|  1   |  -   | true | ...  | ...  | ...  |
   >|  0   | true | ...  | ...  | ...  | ...  |
   >
   >- **填表步骤**：
   >    1. `i=4`：处理 `j=4` → `dp[4][4] = true`（单字符）。
   >    2. `i=3`：处理 `j=3`（单字符）和 `j=4`（判断 `s[3] == s[4]`）。
   >    3. `i=2`：处理 `j=2`, `j=3`, `j=4`（如 `j=4` 时，需要 `dp[3][3]` 的结果）。
   >    4. 以此类推，直到 `i=0`。
   >
   >**4. 错误填表顺序的反例**
   >
   >若 `i` 从前往后遍历（`i=0` → `n-1`），处理 `dp[0][4]` 时需要 `dp[1][3]`，但此时 `i=1` 的循环尚未执行，`dp[1][3]` 未被正确计算，导致错误。
   >
   > **5. 关键结论**
   >
   >- **反向遍历的必要性**：确保大问题的子问题已优先解决。
   >- **动态规划的无后效性**：当前状态的计算不依赖未处理的状态。
   >
   >**6. 总结**
   >
   >填表顺序是动态规划的核心设计之一，其本质是 **确保所有依赖的子状态已提前计算**。在回文子串问题中，通过从下往上、从左到右的填表顺序，完美满足了这一条件，使得算法能够高效正确地找出最长回文子串。

5. **返回值**
   在遍历过程中记录最长回文子串的起始位置 `begin` 和长度 `len`，最终返回 `s.substr(begin, len)`。

6. **时空复杂度**

- **时间复杂度**：O(n²)，双重循环遍历整个字符串。
- **空间复杂度**：O(n²)，维护二维动态规划表。

