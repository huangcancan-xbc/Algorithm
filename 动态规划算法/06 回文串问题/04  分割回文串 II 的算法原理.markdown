### 算法原理

#### 1. 动态规划预处理

定义一个二维数组 `ispal[i][j]`，表示子串 `s[i...j]` 是否为回文。通过动态规划填充该表：
- **状态转移方程**：
  - 若 `s[i] != s[j]`，`ispal[i][j] = false`。
  - 若 `s[i] == s[j]`：
    - 子串长度为 1 或 2（即 `j - i < 2`），则 `ispal[i][j] = true`。
    - 否则，`ispal[i][j] = ispal[i+1][j-1]`（内部子串是否为回文决定当前子串）。
- **填表顺序**：外层循环 `i` 从后向前遍历，内层循环 `j` 从前向后遍历，确保 `ispal[i+1][j-1]` 已被计算。

#### 2. 动态规划求解最小分割次数

![](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/132.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%20II%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86.png)

定义一维数组 `dp[i]`，表示子串 `s[0...i]` 的最小分割次数：
- **初始化**：`dp[i] = INT_MAX`（初始化为极大值），避免影响后续求 `min`，从而影响最终结果。
- **状态转移**：
  - 若 `s[0...i]` 是回文（即 `ispal[0][i] == true`），则 `dp[i] = 0`（无需分割）。
  - 否则，遍历其内部所有可能的分割点 `j`（`1 ≤ j ≤ i`）：
    - 若 `s[j...i]` 是回文（即 `ispal[j][i] == true`），则 `dp[i] = min(dp[i], dp[j-1] + 1)`。
    - 解释：将 `s[0...i]` 分割为 `s[0...j-1]` 和 `s[j...i]`，分割次数为 `dp[j-1] + 1`（`dp[j-1]` 是前半部分的最小分割次数，`+1` 表示当前分割）。注意起始从 1 开始，既避免了 `ispal[j][i]` 和 `ispal[0][i]` 相等的影响，又避免越界 `j-1` 越界。

#### 3. 关键步骤解析

- **预处理回文表**：通过动态规划预处理所有子串的回文性，避免重复判断。大大降低时间复杂度。
- **分割点枚举**：对于每个位置 `i`，尝试所有可能的分割点 `j`，确保后半段 `s[j...i]` 是回文，从而将问题分解为子问题。

#### 4. 示例分析

以 `s = "aab"` 为例：
- `ispal` 表填充后：
  - `ispal[0][0] = true`（单字符回文）
  - `ispal[0][1] = true`（相邻字符相同）
  - `ispal[1][2] = false`（"ab" 不是回文）
  - `ispal[2][2] = true`（单字符回文）
- `dp` 表计算：
  - `dp[0] = 0`（"a" 是回文）
  - `dp[1] = 0`（"aa" 是回文）
  - `dp[2] = min(dp[1] + 1) = 1`（分割为 "aa" 和 "b"）

#### 5. 复杂度分析

- **时间复杂度**：O(n²)，预处理 `ispal` 和计算 `dp` 均为双重循环。
- **空间复杂度**：O(n²)，存储 `ispal` 表。
