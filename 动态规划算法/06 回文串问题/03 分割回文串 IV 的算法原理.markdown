### 算法原理

#### 1. 问题分析

题目要求将字符串分割成三个非空回文子串。需要验证是否存在两个分割点，将字符串划分为三个部分，每个部分均为回文。所以我们可以直接枚举划分的三个部分：

#### 2. 动态规划预处理

首先构建二维数组 `dp[i][j]`，表示子串 `s[i...j]` 是否为回文。利用动态规划填充该表：
- **状态转移方程**：
  - 若 `s[i] != s[j]`，`dp[i][j] = false`（首尾字符不同，无法形成回文）。
  - 若 `s[i] == s[j]`：
    - 子串长度为 1 或 2（即 `j - i < 2`），则 `dp[i][j] = true`（单字符或相邻相同字符）。
    - 否则，`dp[i][j] = dp[i+1][j-1]`（内部子串是否为回文决定当前子串）。
- **填表顺序**：从后向前遍历 `i`（确保处理 `i` 时 `i+1` 行的数据已计算），从前向后遍历 `j`。

#### 3. 分割点枚举

需找到两个分割点 `i` 和 `j`，将字符串划分为三个部分：
1. **第一部分**：`s[0 ... i-1]`
2. **第二部分**：`s[i ... j]`
3. **第三部分**：`s[j+1 ... n-1]`

**分割点取值范围**：

- **第一段非空**：要求 `i >= 1`（第一段至少包含 `s[0]`）。
- **第三段非空**：要求 `j+1 <= n-1` → `j <= n-2`（第三段至少包含 `s[j+1]`）。
- **第二段非空**：要求 `j >= i`（第二段至少包含 `s[i]`）。

因此：

-   **i 的取值范围**：`1 ≤ i ≤ n-2`（确保第一部分和剩余部分可分割）。
-   **j 的取值范围**：`i ≤ j ≤ n-2`（确保第二部分和第三部分非空）。

#### 4. 枚举逻辑

- **外层循环** 遍历 `i`，确定第一段结束位置。
- **内层循环** 遍历 `j`，确定第二段结束位置。
- 若 `dp[0][i-1]`（第一段是回文）、`dp[i][j]`（第二段是回文）、`dp[j+1][n-1]`（第三段是回文）均为 `true`，则存在合法分割，返回 `true`。

#### 6. 复杂度分析

- **时间复杂度**：O(n²)，动态规划预处理和分割点枚举均为双重循环。
- **空间复杂度**：O(n²)，存储动态规划表。
