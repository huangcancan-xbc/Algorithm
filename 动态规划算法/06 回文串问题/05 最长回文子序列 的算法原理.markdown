### 算法原理

#### 状态定义

- **`dp[i][j]`** 表示子字符串 `s[i...j]` 的最长回文子序列的长度。

#### 状态转移

![d310a8c33c98a3996ab6bfb3c7629acc](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/d310a8c33c98a3996ab6bfb3c7629acc.png)

1. **基础情况**：
   当 `i == j` 时（单个字符），`dp[i][j] = 1`（单个字符本身是回文）。

2. **字符相等**：
   若 `s[i] == s[j]`，则这两个字符可以作为回文的两端，此时：
   - 若 `i + 1 < j`，则 `dp[i][j] = dp[i+1][j-1] + 2`（中间部分的最长回文加上两端）。
   - 若 `i + 1 == j`，则 `dp[i][j] = 2`（相邻字符直接构成回文）。

3. **字符不等**：
   若 `s[i] != s[j]`，则最长回文只能从两个子问题中取最大值：
   - `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`（忽略左端或右端字符后的最大值）。

#### 遍历顺序
- **外层循环**：从后向前遍历 `i`（从 `n-1` 到 `0`），保证处理子区间 `[i+1, j-1]` 时其值已计算。
- **内层循环**：对于每个 `i`，从 `i+1` 开始遍历 `j`，逐步扩展区间。

#### 返回值

**`dp[i][j]`** 表示子字符串 `s[i...j]` 的最长回文子序列的长度。我们直接返回 `dp[0][n-1]` 表示从开头到结尾的最长回文子序列的长度，即最终答案。

#### 复杂度分析

- **时间复杂度**：O(n²)，需要填充一个 `n x n` 的二维数组。
- **空间复杂度**：O(n²)，用于存储 `dp` 表。

