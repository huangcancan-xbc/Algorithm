### 算法原理

先将问题「转化」成熟悉的题型。
1. 在一些物品中「挑选」一些出来，然后在满足某个「限定条件」下，解决一些问题，大概率是「背包」模型；
2. 由于每一个物品都是无限多个的，因此是一个「完全背包」问题。接下来的分析就是基于「完全背包」的方式来的。

![image-20250305165437550](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250305165437737.png)

---

#### 1. 状态表示

`dp[i][j]` 表示：从前 `i` 个硬币中挑选，总和正好等于 `j` ，所有的选法中，最少的硬币个数。

#### 2. 状态转移方程

线性 dp 状态转移方程分析方式，一般是根据「最后一步」的状况，来分情况讨论。但是最后一个物品能选很多个，因此我们的需要分很多情况：
- 选 0 个第 `i` 个硬币：此时相当于就是去前 `i - 1` 个硬币中挑选，总和正好等于 `j` 。此时最少的硬币个数为 `dp[i - 1][j]`；
- 选 1 个第 `i` 个硬币：此时相当于就是去前 `i - 1` 个硬币中挑选，总和正好等于 `j - coins[i]`。因为挑选了一个 `i` 硬币，此时最少的硬币个数为 `dp[i - 1][j - coins[i]] + 1`；
- 选 2 个第 `i` 个硬币：此时相当于就是去前 `i - 1` 个硬币中挑选，总和正好等于 `j - 2 * coins[i]`。因为挑选了两个 `i` 硬币，此时最少的硬币个数为 `dp[i - 1][j - 2 * coins[i]] + 2`；
- ...... 

结合在完全背包里面的优化思路，我们最终得到的状态转移方程为：
$$
dp [i][j] = \min(dp [i - 1][j], dp [i][j - coins[i]] + 1)
$$
一个技巧：就是相当于把第二种情况 `dp[i - 1][j - coins[i]] + 1` 里面的 `i - 1` 变成 `i` 即可。

#### 3. 初始化
初始化第一行即可。这里因为取 `min`，所以我们可以把无效的地方设置成无穷大 (`0x3f3f3f3f`)。因为这里要求正好凑成总和为 `j`，因此，需要把第一行除了第一个位置的元素，都设置成无穷大。

-   `dp[0] = 0`（凑出金额 0 需要 0 枚硬币）。
-   其他 `dp[i]` 先赋一个很大的值（`INF = 0x3f3f3f3f`），表示目前无法凑出该金额，避免整数溢出。

#### 4. 填表顺序

根据「状态转移方程」，我们仅需「从上往下」填表即可。

#### 5. 返回值
根据「状态表示」，返回 `dp[n][V]`。但是要特判一下，因为有可能凑不到。最终检查 `dp[amount]` 的值，若大于等于预设的极大值 `INF`，返回-1，否则返回该值。

---

#### 一维 dp 状态转移方程

消去 `i` 维度，直接用 `dp[j]` 进行更新：
$$
dp [j] = min⁡(dp [j], dp [j−coins[i−1]]+1)
$$

-   其中 `dp[j]` 表示 **凑出金额 j 所需的最少硬币数**。
-   `dp[j - coins[i-1]]` 表示 **去掉当前硬币后剩余金额的最优解**。

**遍历方式**

-   **外层遍历硬币 `i`**，保证每种硬币都能选到。
-   **内层遍历金额 `j`，从 `coins[i-1]` 开始到 `amount`**，确保 `dp[j - coins[i-1]]` 在 `dp[j]` 计算时已经被更新。

#### 为什么内层要从 `coins[i]` 开始？

**保证每个硬币可以被多次使用（确保 `dp[j - coins[i]]` 在当前轮迭代中已更新，保证完全背包的正确性。）**

-   因为 `dp[j] = min(dp[j], dp[j - coins[i]] + 1)` 依赖 `dp[j - coins[i]]`，如果从 `0` 开始遍历 `j`，会导致 `dp[j - coins[i]]` 还没更新，影响正确性。
-   从 `coins[i]` 开始，可以确保 `dp[j - coins[i]]` 在 `dp[j]` 计算时已经是 **当前轮计算的最新值**，不会被覆盖。