### 完全背包问题算法原理

#### 问题描述

给定 `n` 个物品，每个物品有体积 `v[i]` 和价值 `w[i]`，背包容量为 `V`。每个物品可无限次选取。
**两个任务**：  

1. 求背包能容纳的 **最大价值**（不要求恰好装满）。  
2. 求 **恰好装满背包** 时的最大价值，若无法恰好装满则输出 `0`。

![image-20250305150017529](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250305150017857.png)

---

### 问题一：最大价值（不要求装满）

#### 1. 状态定义

- `dp[i][j]` 表示从前 `i` 个物品中选，总体积不超过 `j` 的最大价值，所有选法中的最大价值。

#### 2. 状态转移方程

对于每个物品 `i` 和容量 `j`：  
- **不选当前物品**：继承前 `i-1` 个物品的结果，即 `dp[i][j] = dp[i-1][j]`。  
- **选当前物品**（需满足 `j ≥ v[i]`）：  
  - 允许重复选择，因此状态来自同一行：`dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i])`。  

**数学推导**：
若选择 `k` 个物品 `i`，则总价值为 `dp[i-1][j - k*v[i]] + k*w[i]`。
通过观察发现，`dp[i][j - v[i]]` 已经包含了选择 `k-1` 个物品 `i` 的最优解，因此只需比较 `dp[i-1][j]` 和 `dp[i][j - v[i]] + w[i]`。

>#### 详细推导过程
>
>我们先从最原始的定义出发。在完全背包问题中，对于第 `i` 个物品，我们可以选 0 次、1 次、2 次，……直到放满背包容量为止。用数学表达即为：
>
>$$
>dp [i][j] = \max_{k \ge 0,\; k\cdot v [i] \le j} \Bigl\{ dp [i-1][j-k\cdot v[i]] + k\cdot w [i] \Bigr\}
>$$
>
>这里，`k` 表示选择第 `i` 个物品的次数。注意到当  `k = 0` 时，其值为 `dp[i-1][j]`（即不选），而 `k≥1`  表示至少选一个物品。
>
>---
>
>#### 如何将所有可能的 `k` 合并成一个状态转移方程？
>
>我们希望通过递推关系将“选择至少一次”这一部分表示成单个式子。考虑当我们已经选了至少一次时，我们令 `k≥1`：
>
>1. **设定初始状态：**
>
>   对于 `k≥1`，原式为  
>
> $$
>   dp [i][j] = \max_{k \ge 1,\; k\cdot v [i] \le j} \Bigl\{ dp [i-1][j - k\cdot v[i]] + k\cdot w [i] \Bigr\}
> $$
>
>2. **把 k 的选择次数拆分：**
>
>   注意到如果我们将选取次数从 `k` 拆分为“先选一次，再选 `k - 1` 次”，那么可以写为：
>   
> $$
>   dp [i][j] = \max_{k \ge 1} \Bigl\{ dp [i-1][j - k\cdot v[i]] + k\cdot w [i] \Bigr\}
> $$
>   
>   而对于每个 `k≥1`，令 `k' = k - 1` ，就有：
>   
> $$
>   dp [i-1][j-k\cdot v[i]] + k\cdot w [i] = \Bigl( dp [i-1][j-v[i]-k'\cdot v [i]] + k'\cdot w [i] \Bigr) + w [i]
> $$
>
>3. **观察状态转移的结构：**
>
>   注意到 `dp[i][j-v[i]]`  定义为：
>   
> $$
>   dp [i][j-v[i]] = \max_{k' \ge 0,\; k'\cdot v [i] \le j-v [i]} \Bigl\{ dp [i-1][j-v[i]-k'\cdot v [i]] + k'\cdot w [i] \Bigr\}
> $$
>   
>   如果我们在上式两边加上 `w[i]` ，则得到：
>   
> $$
>   dp [i][j-v[i]] + w [i] = \max_{k' \ge 0} \Bigl\{ dp [i-1][j-v[i]-k'\cdot v [i]] + k'\cdot w [i] + w [i] \Bigr\}
> $$
>   
>   而右边正好等价于考虑至少选 1 次（令 `k' = k - 1`）的所有可能性：
>   
> $$
>   = \max_{k \ge 1} \Bigl\{ dp [i-1][j-k\cdot v[i]] + k\cdot w [i] \Bigr\}
> $$
>
>4. **合并两种情况：**
>
>   原始状态转移式中，不选与至少选一次都考虑了，即：
>   
> $$
>   dp [i][j] = \max \Bigl\{ dp [i-1][j],\; \max_{k\ge1} \{dp [i-1][j-k\cdot v[i]] + k\cdot w [i]\} \Bigr\}
> $$
>   
>   通过上面的推导，我们可以将“至少选一次”的部分写成 `dp[i][j-v[i]] + w[i]` 。因此整体的状态转移公式就变成了：
>   
> $$
>   dp [i][j] = \max \Bigl\{ dp [i-1][j],\; dp [i][j-v[i]] + w [i] \Bigr\}
> $$
>
>#### 总结推导过程
>
>- **初始枚举：**
>
> 直接枚举 0 次到 `k` 次的所有可能状态，得：
>
> $$
>   dp [i][j] = \max_{0 \le k \le \lfloor j/v [i] \rfloor} \{ dp [i-1][j-k\cdot v[i]] + k\cdot w [i] \}
> $$
> 
> - **拆分思路：**
>
> 将“选 `k` 次”拆分为“先选一次，再选 `k - 1` 次”，使得剩余问题变成同样的子问题。
>
> - **归纳与合并：**
>
> 注意到选至少一次时，可以将 `dp[i][j-v[i]]` 表示为已经考虑了所有 `k′≥0` 的可能，进而加上一次  `w[i]`  就覆盖了 `k≥1` 的情况。
>
> - **得到简洁公式：**
>
> 最终得到
>
> $$
>   dp [i][j] = \max \bigl\{ dp [i-1][j],\; dp [i][j-v[i]] + w [i] \bigr\}
> $$
> 
>  这个公式不仅表达了“不选”和“至少选一次”的两种情况，而且通过递归自引用将多次选择的情况归纳到了一条状态转移中。还利用了 **状态重叠** 和 **递归分解** 的思想，避免了显式枚举所有可能的选择次数，从而大大简化了状态转移方程。
>  

#### 3. 初始化

- `dp[0][j] = 0`：没有物品时，最大价值为 `0`。

#### 4. 填表顺序

- **外层循环遍历物品**（`i` 从 `1` 到 `n`），**内层循环正序遍历容量**（`j` 从 `v[i]` 到 `V`）。  
- **正向遍历原因**：允许重复选择当前物品，需利用已更新的状态 `dp[i][j - v[i]]`。

#### 5. 空间优化

- 用一维数组 `dp[j]` 代替二维数组，**正序遍历容量**：  
  ```cpp
  for (int i = 1; i <= n; i++)
  {
      for (int j = v[i]; j <= V; j++)
      {
          dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
      }
  }
  ```

---

### 问题二：恰好装满背包的最大价值

#### 1. 状态定义

- `dp[i][j]` 表示从前 `i` 个物品中选，总体积 **恰好等于** `j` 的最大价值。

#### 2. 状态转移方程

- **不选当前物品**：继承前 `i-1` 个物品的结果，即 `dp[i][j] = dp[i-1][j]`。  
- **选当前物品**（需满足 `j ≥ v[i]` **且** `dp[i][j - v[i]]` 有效）：  
  - 若 `dp[i][j - v[i]] ≠ -1`，则更新：`dp[i][j] = max(dp[i][j], dp[i][j - v[i]] + w[i])`。  

#### 3. 初始化

- `dp[0][0] = 0`：空背包体积为 `0`，有效。  
- `dp[0][j] = -1`（`j > 0`）：没有物品时，无法恰好装满非零容量。  

#### 4. 填表顺序

- 同问题一，但需在转移时检查前驱状态是否有效。

#### 5. 返回值

-   由于最后可能凑不成体积为 `V` 的情况，因此返回之前需要特判一下：`dp[n][V] == -1 ? 0 : dp[n][V]`。

---

### 优化原理

后面两种优化代码的优化原理是 **利用一维 `dp` 数组** 来 **减少空间复杂度**，并在第二次计算时 **改进无解状态的初始化方式**。解释：

#### 第一种优化：使用一维 `dp` 数组代替二维 `dp[i][j]`

1.  **原始二维 DP（`dp[i][j]`）**
    -   之前的二维 `dp[i][j]` 记录考虑前 `i` 个物品时，容量为 `j` 的最大价值。
    -   `dp[i][j] = max(dp[i-1][j], dp[i][j-v[i]] + w[i])`
         这个状态转移方程可以看出，`dp[i][j]` 只依赖 `dp[i-1][j]` 和 `dp[i][j-v[i]]`。
    -   由于 `dp[i][j]` 只与上一层 `dp[i-1][j]` 相关，因此可以用 **滚动数组** 的方式优化，将 `dp[i][j]` 改为 `dp[j]`，即只用一维数组 `dp[j]` 记录当前状态。
2.  **空间优化：使用一维 `dp`**
    -   `dp[j] = max(dp[j], dp[j - v[i]] + w[i])`，直接在一维数组上更新状态。
    -   **遍历顺序**：`j` **从小到大遍历**（`v[i] → V`），保证 **每个物品可以被多次选取**，符合完全背包的特点。
    -   空间复杂度降低为 **O(V)**，而不是 **O(nV)**。

#### 第二种优化：处理无解情况

##### 优化点

1.  **第一种优化的不足**：

    -   `memset(dp, 0, sizeof dp);` 之后，默认 `dp[j] = 0`，但 `dp[j]` 代表的是容量为 `j` 的最大价值。

    -   对于某些 `j`，如果无法由物品组合得到 `j`，`dp[j]` 仍然是 `0`，导致无法区分是 **价值为 0 还是无法凑出**。

    -   例如：

        ```cpp
        memset(dp, 0, sizeof dp);
        for (int i = 1; i <= V; i++)
        {
            dp[i] = -1; // 明确标记无解
        }
        ```

        这里将 `dp[i]` 设为 `-1`，用于表示该状态无法凑出。

2.  **进一步优化**：

    -   由于 `dp[j]` 需要存储最大价值，`-1` 可能会影响计算，因此可以换成一个极小值 `-0x3f3f3f3f`，确保不会影响 `max(dp[j], dp[j - v[i]] + w[i])` 的计算。
    -   `-0x3f3f3f3f` 相当于一个非常小的负数（接近 `int` 最小值），可以用于区分无解情况，避免误把 `0` 当作无解。

3.  **遍历顺序**：

    -   `j` **仍然从小到大遍历**，保证物品可以多次选取。

---

| 方案        | 状态存储   | 遍历顺序           | 处理无解方法          | 空间复杂度 |
| ----------- | ---------- | ------------------ | --------------------- | ---------- |
| 原始二维 DP | `dp[i][j]` | `i` 外层，`j` 内层 | `dp[i][j] = 0`        | O(nV)      |
| 第一种优化  | `dp[j]`    | `j` **从小到大**   | `dp[j] = 0`           | O(V)       |
| 第二种优化  | `dp[j]`    | `j` **从小到大**   | `dp[j] = -0x3f3f3f3f` | O(V)       |

**两次优化的核心**：

1.  **第一步优化**：用 **一维 `dp` 数组** 优化空间复杂度，从 `O(nV)` 降到 `O(V)`。
2.  **第二步优化**：用 `-0x3f3f3f3f` 处理无解情况，避免 `0` 误导，确保正确计算最大价值。

