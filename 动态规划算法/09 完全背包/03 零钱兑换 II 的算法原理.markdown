### 算法原理

![image-20250305180828342](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250305180828543.png)

#### 1. 状态定义

- **二维 DP**：`dp[i][j]` 表示使用前 `i` 种硬币凑出金额 `j` 的组合数。
- **核心思想**：通过动态规划逐步累加组合数，区分“不选当前硬币”和“选当前硬币”两种情况。

#### 2. 状态转移方程

- **不选当前硬币**：组合数等于前 `i-1` 种硬币凑出 `j` 的组合数，即：
  
  ```cpp
  dp[i][j] = dp[i-1][j]
  ```
- **选当前硬币**：组合数等于使用前 `i` 种硬币凑出 `j - coins[i-1]` 的组合数（允许重复使用），即：
  ```cpp
  dp[i][j] += dp[i][j - coins[i-1]]
  ```
- **统一表达式**：
  
  ```cpp
  dp[i][j] = dp[i-1][j] + (j >= coins[i-1] ? dp[i][j - coins[i-1]] : 0)
  ```

#### 3. 初始化

- **基础情况**：`dp[0][0] = 1`，表示不选任何硬币时凑出金额 0 有 1 种方法。
- **无效情况**：`dp[0][j] = 0`（`j > 0`），因为无硬币时无法凑出正金额。

#### 4. 填表顺序

- **外层遍历硬币**：从第 1 种到第 `n` 种硬币。
- **内层遍历金额**：从小到大遍历金额 `j`（0 到 `amount`），确保硬币可重复使用。

#### 5. 溢出处理（代码细节）

- 在代码中，当 `dp[i][j - coins[i-1]] + dp[i][j]` 可能超过 `INT_MAX` 时，跳过更新：
  ```cpp
  if (dp[i][j - coins[i-1]] > INT_MAX - dp[i][j])
  {
      continue;
  }
  ```

#### 关于 `static_cast<int>(dp[n][amount])`

`static_cast<int>(dp[n][amount])` 是一种类型转换操作，用于将 `dp[n][amount]` 的值从其原始类型转换为 `int` 类型。

使用 `static_cast<int>()` 进行类型转换时需要注意，如果 `dp[n][amount]` 的值超出了 `int` 类型能够表示的范围（通常是 `-2^31` 到 `2^31-1`），那么转换后的值可能会丢失精度或产生意外的行为。
