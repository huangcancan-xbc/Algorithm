### 详细算法讲解

01 背包问题分为两个子问题：  
1. **普通背包**：求不超过背包容量的最大价值  
2. **恰好装满**：求恰好装满背包时的最大价值（若无法装满则输出 0）

![image-20250228163229289](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250228163229455.png)

---

#### 一、普通背包问题（问题 1）

##### 1. 状态表示
- **`dp[i][j]` 的含义**：考虑前 `i` 个物品，背包容量为 `j` 时能获得的最大价值（从前 `i` 个物品中挑选，总体积不超过 `j`，所有选法中能挑出来的最大价值）。 
- **目标状态**：`dp[n][V]`（即考虑所有物品，容量为 `V` 时的最大价值）。

##### 2. 状态转移方程

对于第 `i` 个物品（体积 `v[i]`，价值 `w[i]`）：  
- **不选第 `i` 个物品**：`dp[i][j] = dp[i-1][j]`（继承前 `i-1` 个物品的结果）。  
- **选第 `i` 个物品**（需满足 `j >= v[i]` → `j-v[i] >= 0`）：`dp[i][j] = dp[i-1][j-v[i]] + w[i]`。  
- **最终决策**：取两者的最大值，即：  
  
  ```cpp
  dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + w[i]);
  ```

##### 3. 初始化
- **初始条件**：当没有物品时（`i=0`），无论容量多大，价值均为 0。  
  
  ```cpp
  for (int j = 0; j <= V; j++)
  {
      dp[0][j] = 0;
  }
  ```

##### 4. 填表顺序
- **外层循环遍历物品**（`i` 从 1 到 `n`）。  
- **内层循环遍历容量**（`j` 从 1 到 `V`）。  
- **顺序要求**：必须先处理小容量，再处理大容量（因为需要依赖上一行的左方格子）。

##### 5. 示例说明
以输入 `n=3, V=5`，物品体积为 `[2,4,1]`，价值为 `[10,5,4]` 为例：
- **最终结果**：`dp[3][5] = 14`（选择第 1 和第 3 个物品）。

---

#### 二、恰好装满背包（问题 2）

##### 1. 状态表示
- **`dp[i][j]` 的含义**：考虑前 `i` 个物品，**恰好装满** 容量 `j` 时的最大价值（若无法装满则标记为无效值 `-1`）（从前 `i` 个物品中挑选，总体积正好等于 `j`，所有选法中能挑出来的最大价值）。   
- **目标状态**：`dp[n][V]`（若为 `-1` 则表示无法装满）。

##### 2. 状态转移方程

- **不选第 `i` 个物品**：`dp[i][j] = dp[i-1][j]`（继承前 `i-1` 个物品的结果）。  
- **选第 `i` 个物品**（需满足 `j >= v[i]` → `j-v[i] >= 0` **且前一状态有效**）：  
  
  ```cpp
  if (dp[i-1][j-v[i]] != -1)
  {
      dp[i][j] = max(dp[i][j], dp[i-1][j-v[i]] + w[i]);
  }
  ```

##### 3. 初始化
- **初始条件**：当没有物品时（`i=0`）：  
  - 只有容量为 0 时是有效的（恰好装满），即 `dp[0][0] = 0`。  
  - 其他容量均无效，标记为 `-1`。  
  ```cpp
  for (int j = 1; j <= V; j++)
  {
      dp[0][j] = -1;  // 不选物品时无法装满j>0的背包
  }
  ```

##### 4. 填表顺序
与普通背包相同，但需注意 **无效状态的传递**：只有当左上方格子有效时，才能进行转移。

##### 5. 示例说明
以输入 `n=3, V=8`，物品体积为 `[12,11,6]`，价值为 `[6,8,8]` 为例：
- **最终结果**：`dp[3][8] = -1` → 输出 `0`（无法恰好装满）。

---

#### 区别分析

| 问题类型       | 初始化差异                  | 转移条件差异                   | 目标状态含义           |
| -------------- | --------------------------- | ------------------------------ | ---------------------- |
| 普通背包       | `dp[0][j] = 0`（允许不满）  | 无条件转移                     | 允许不满，求最大价值   |
| 恰好装满的背包 | `dp[0][j] = -1`（必须装满） | 需检查前一状态是否有效（非-1） | 必须恰好装满，否则无效 |

#### 时间复杂度与空间复杂度

- **时间复杂度**：O(nV)（双重循环）。  
- **空间复杂度**：O(nV)（二维数组）。

---

### 两个一维数组实现滚动数组优化原理说明

#### 1. 状态表示压缩

将二维数组 `dp[i][j]` 压缩为一维数组 `dp[j]`：
- **`dp[j]` 的含义**：容量为 `j` 的背包能获得的最大价值。
- **`full_dp[j]` 的含义**：容量为 `j` 的背包 **恰好装满** 时的最大价值（`-1` 表示无法恰好装满）。

#### 2. 逆序遍历容量的必要性

- **正序遍历问题**：如果正序更新 `dp[j]`，小容量的状态会被提前覆盖，导致大容量计算时使用错误的前置状态。
- **逆序遍历解决**：从 `V` 到 `v[i]` 逆序更新，保证 `dp[j - v[i]]` 始终是上一轮（未更新）的状态。

#### 3. 普通背包（允许不满）的初始化与转移

- **初始化**：所有容量初始化为 0，表示允许不满。
- **状态转移**：
  ```cpp
  for (int j = V; j >= v[i]; j--)
  {
      dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
  }
  ```
  解释：每次决策是否将当前物品加入背包，取最大值。

#### 4. 恰好装满的初始化与转移

- **初始化**：
  ```cpp
  memset(full_dp, -1, sizeof(full_dp)); // -1表示不可达
  full_dp[0] = 0; // 容量0时价值为0（有效状态）
  ```
- **状态转移**：
  ```cpp
  if (full_dp[j - v[i]] != -1)
  {
      full_dp[j] = max(full_dp[j], full_dp[j - v[i]] + w[i]);
  }
  ```
  解释：只有当 `j - v[i]` 可达时，才能通过加入当前物品转移到 `j`。

---

#### 关键区别总结

| 问题类型       | 初始化                        | 转移条件                       | 输出规则         |
| :------------: | ----------------------------- | ------------------------------ | ---------------- |
| 普通背包       | `dp[j] = 0`                   | 无条件更新                     | 直接输出 `dp[V]` |
| 恰好装满的背包 | `full_dp[0] = 0`，其他为 `-1` | 仅当 `full_dp[j - v[i]] != -1` | 若为 `-1` 输出 0  |

#### 示例验证

**输入 1**：

```
3 5
2 10
4 5
1 4
```
**输出**：
```
14
9
```
- **普通背包**：选择物品 1 和 3，总价值 14。
- **恰好装满**：选择物品 2 和 3，总价值 9。

**输入 2**：
```
3 8
12 6
11 8
6 8
```
**输出**：
```
8
0
```
- **普通背包**：选择物品 3，总价值 8（未满）。
- **恰好装满**：无法装满，输出 0。

---

### 一个一维数组实现滚动数组优化原理说明

#### 一、普通背包问题（允许不满）

##### 1. 状态定义与压缩
- **原始二维状态**：`dp[i][j]` 表示前 `i` 个物品，容量为 `j` 时的最大价值。
- **一维压缩**：`dp[j]` 表示容量为 `j` 的背包能获得的最大价值。
  

**优化关键**：每一行 `i` 的计算仅依赖上一行 `i-1` 的数据。通过逆序更新 `j`，可以覆盖旧状态而不影响后续计算。

##### 2. 状态转移方程
对于每个物品 `i`，逆序遍历容量 `j`（从 `V` 到 `v[i]`）：
```cpp
dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
```
- **逆序的意义**：保证 `dp[j - v[i]]` 是上一轮（未考虑当前物品）的状态，避免覆盖。

##### 3. 初始化
- **初始条件**：`dp[0...V] = 0`，表示没有物品时所有容量的最大价值为 0。

##### 4. 示例分析
假设输入 `n=3, V=5`，物品体积 `v=[2,4,1]`，价值 `w=[10,5,4]`：
- **处理物品 1（体积 2，价值 10）**：
  - `j=5`: `dp[5] = max(0, dp[3] + 10) = 10`
  - `j=4`: `dp[4] = max(0, dp[2] + 10) = 10`
  - `j=3`: `dp[3] = max(0, dp[1] + 10) = 10`
  - `j=2`: `dp[2] = max(0, dp[0] + 10) = 10`
- **处理物品 3（体积 1，价值 4）**：
  - `j=5`: `dp[5] = max(10, dp[4] + 4) = 14`（最终结果）

#### 二、恰好装满背包

##### 1. 状态定义与压缩
- **原始二维状态**：`full_dp[i][j]` 表示前 `i` 个物品，**恰好装满** 容量 `j` 时的最大价值。
- **一维压缩**：`dp[j]` 表示恰好装满容量 `j` 时的最大价值（`-1` 表示不可达）。

##### 2. 初始化
- **初始条件**：`dp[0] = 0`（容量 0 时价值为 0），`dp[1...V] = -1`（不可达）。

##### 3. 状态转移方程
逆序遍历容量 `j`（从 `V` 到 `v[i]`），仅当 `dp[j - v[i]] != -1` 时更新：
```cpp
if (dp[j - v[i]] != -1)
{
    dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
}
```
- **严格条件**：必须从有效状态转移，确保最终结果严格装满。

##### 4. 示例分析
假设输入 `n=3, V=5`，物品同上：
- **处理物品 2（体积 4，价值 5）**：
  - `j=5`: `j - v[i] = 1`（不可达，不更新）
  - `j=4`: `dp[4] = max(-1, dp[0] + 5) = 5`
- **处理物品 3（体积 1，价值 4）**：
  - `j=5`: `j - v[i] = 4`（`dp[4]=5` 有效） → `dp[5] = max(-1, 5 + 4) = 9`

#### 关键点

|     维度     | 普通背包（允许不满） | 恰好装满的背包                 |
| :----------: | :------------------- | ------------------------------ |
|  **初始化**  | `dp[0...V] = 0`      | `dp[0] = 0`, `dp[1...V] = -1`  |
| **转移条件** | 无条件更新 `dp[j]`   | 仅当 `dp[j - v[i]]` 有效时更新 |
| **输出规则** | 直接取 `dp[V]`       | 若 `dp[V] = -1` 则输出 0        |

#### 空间复杂度优化

- **二维数组空间**：O(nV) → **一维数组空间**：O(V)。  
- **核心技巧**：逆序更新覆盖旧状态，确保每个物品只被处理一次。

