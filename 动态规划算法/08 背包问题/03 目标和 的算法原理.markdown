### 算法原理

#### 问题描述

给定一个非负整数数组 `nums` 和一个目标整数 `target`，通过在数组每个元素前添加 `+` 或 `-`，使得表达式的结果等于 `target`。求所有可能的符号组合数目。

#### 核心思路：转换为子集和问题

1. **问题转化**：  
   - 将数组分为两个子集 `A`（正号元素）和 `B`（负号元素），满足 `A - B = target`。  
   - 数组总和 `sum = A + B`，联立方程得 `2A = sum + target` → `A = (sum + target) / 2`。  
   - **目标**：找到和为 `A` 的子集数目（记为 `aim`）。

2. **边界条件**：  
   - 若 `sum + target` 为奇数或 `aim < 0`，则无解，返回 0。  

![image-20250304202050492](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250304202050856.png)

---

### 动态规划设计

#### 1. 状态表示

- **二维版本**：`dp[i][j]` 表示前 `i` 个元素中和正好等于 `j` 的所有选法。  
- **一维优化**：`dp[j]` 表示和为 `j` 的子集数目，通过逆序遍历压缩空间。

#### 2. 状态转移方程

- **不选当前元素**：方案数继承 `dp[i-1][j]`。  
- **选当前元素**（若 `j >= nums[i-1]`）：方案数累加 `dp[i-1][j - nums[i-1]]`。  

**状态转移方程**：  

```cpp
dp[i][j] = dp[i-1][j] + (j >= nums[i-1] ? dp[i-1][j - nums[i-1]] : 0);
```

#### 3. 初始化

-   **`dp[0][0] = 1`**：表示前 0 个元素（空集）中和为 0 的子集数目为 1（不选任何元素）。
-   **其他位置初始化为 0**：表示前 0 个元素无法形成非零和。

>#### 为什么只初始化第一个位置？
>
>1.  **空集和为 0 的方案数**：
>    -   空集是唯一的和为 0 的子集，因此 `dp[0][0] = 1`。
>    -   其他 `dp[0][j]`（`j > 0`）表示空集无法形成非零和，因此初始化为 0。
>2.  **第一列的初始化**：
>    -   `dp[i][0]` 表示前 `i` 个元素中和为 0 的子集数目。
>    -   若所有元素均为正数，则只有空集满足和为 0，因此 `dp[i][0] = 1`（`i >= 0`）。
>    -   但若存在元素为 0，则可能有多个子集满足和为 0（例如 `nums = [0,0,0]`，和为 0 的子集有多个）。
>    -   **代码中未显式初始化第一列**，因为状态转移会正确处理：
>        -   若 `nums[i-1] = 0`，则 `dp[i][0] = dp[i-1][0] + dp[i-1][0] = 2 * dp[i-1][0]`。
>        -   若 `nums[i-1] > 0`，则 `dp[i][0] = dp[i-1][0]`。
>
>#### 为什么第一列不担心越界？
>
>1.  **状态转移的范围**：
>    -   在状态转移中，`dp[i][j]` 的计算仅依赖 `dp[i-1][j]` 和 `dp[i-1][j - nums[i-1]]`。
>    -   当 `j = 0` 时，`j - nums[i-1]` 可能为负数，但代码中通过 `if (j >= nums[i-1])` 判断避免了越界。
>2.  **第一列的特殊性**：
>    -   当 `j = 0` 时，`dp[i][0]` 表示前 `i` 个元素中和为 0 的子集数目。
>    -   若 `nums[i-1] > 0`，则 `dp[i][0] = dp[i-1][0]`（不选当前元素）。
>    -   若 `nums[i-1] = 0`，则 `dp[i][0] = dp[i-1][0] + dp[i-1][0] = 2 * dp[i-1][0]`（选或不选当前元素）。
>3.  **代码中的处理**：
>    -   代码中未显式初始化第一列，但通过状态转移正确处理了所有情况。
>    -   例如，`nums = [0,0,0]`：
>        -   `dp[1][0] = 2`（选或不选第一个 0）。
>        -   `dp[2][0] = 4`（选或不选第二个 0）。
>        -   `dp[3][0] = 8`（选或不选第三个 0）。

---

### 一维 DP 优化原理

1. **空间压缩**：  
   - 二维数组中每行仅依赖上一行，可用一维数组滚动更新。  
2. **逆序遍历**：  
   - 若正序更新，`dp[j - nums[i-1]]` 会被当前行覆盖，导致重复计数。  
   - **逆序** 从 `aim` 到 `nums[i-1]` 更新，确保 `dp[j - nums[i-1]]` 始终引用上一行的状态。  

**一维转移方程**：  

```cpp
for (int j = aim; j >= nums[i-1]; j--)
{
    dp[j] += dp[j - nums[i-1]];  // 逆序避免覆盖
}
```

---

### 边界条件的特判优化

1. **`sum + target` 为奇数**：  
   - 例如 `nums = [1,2], target = 2`，`sum = 3` → `sum + target = 5`（奇数），返回 0。  
2. **`aim < 0`**：  
   - 例如 `nums = [1], target = -3`，`sum = 1` → `aim = (-3 + 1)/2 = -1`，返回 0。  
