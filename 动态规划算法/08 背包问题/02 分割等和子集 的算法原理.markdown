### 算法原理

#### 一、问题理解

判断一个非空数组是否可以被分割成两个子集，使得两个子集的元素和相等。

**关键条件**：  

1. 数组总和必须是偶数（否则直接返回 `false`）  
2. 存在一个子集的和等于总和的一半（即 `target = sum / 2`）

![image-20250303224009391](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250303224009577.png)

---

#### 二、二维动态规划解法

##### 1. 状态定义

- `dp[i][j]` 表示从数组前 `i` 个元素中选取若干元素，是否可以使它们的和等于 `j`。

##### 2. 初始化

- `dp[i][0] = true`：不选取任何元素时，和为 `0`（空子集）。  
- `dp[0][j] = false`（除 `j=0`）：没有元素可选时，无法得到非零和。

##### 3. 状态转移方程
对于每个元素 `nums[i-1]`（注意索引从 0 开始），有两种选择：
- **不选当前元素**：继承前 `i-1` 个元素的状态，即 `dp[i][j] = dp[i-1][j]`。  
- **选当前元素**：需满足 `j >= nums[i-1]`，且前 `i-1` 个元素能组成 `j - nums[i-1]`，即 `dp[i][j] |= dp[i-1][j - nums[i-1]]`。

##### 4. 填表顺序
- 外层遍历元素 `i`（从 1 到 `n`），内层遍历目标和 `j`（从 1 到 `target`）。

##### 5. 最终结果
- `dp[n][target]`：前 `n` 个元素是否能组成和为 `target` 的子集。

---

#### 三、优化到一维动态规划的原理

二维动态规划的空间复杂度为 `O(n*target)`，但通过观察可以发现：每一行的状态仅依赖于上一行的状态。因此可以优化为一维数组。

##### 1. 状态定义

- `dp[j]` 表示是否可以通过选取若干元素，使得它们的和等于 `j`（无需记录元素数量）。

##### 2. 关键优化点

- **空间压缩**：用一维数组替代二维数组，节省空间。
- **逆序遍历**：内层循环从 `target` 到 `nums[i-1]` 逆序更新，避免重复使用同一元素。

##### 3. 逆序遍历的数学原理
假设当前处理第 `i` 个元素 `nums[i-1]`：
- **正序遍历问题**：若从小到大更新 `j`，当处理到较大的 `j` 时，`dp[j - nums[i-1]]` 可能已经被当前轮的更新覆盖（即同一个元素被多次选取），导致错误（类似完全背包问题）。
- **逆序遍历解决**：从大到小更新 `j`，保证在计算 `dp[j]` 时，`dp[j - nums[i-1]]` 仍是上一轮（即前 `i-1` 个元素）的状态，确保每个元素最多被选一次。

##### 4. 状态转移方程（一维）
```cpp
for (int j = target; j >= nums[i-1]; j--)
{
    dp[j] = dp[j] || dp[j - nums[i-1]];  // 不选或选当前元素
}
```

##### 5. 初始化
- `dp[0] = true`：不选任何元素时，和为 `0`。  
- 其他位置初始化为 `false`。

---

#### 四、代码对比与优化依据

##### 原始二维代码片段

```cpp
vector<vector<bool>> dp(n + 1, vector<bool>(target + 1, false));
for (int i = 0; i <= n; i++) dp[i][0] = true;

for (int i = 1; i <= n; i++)
{
    for (int j = 1; j <= target; j++)
    {
        dp[i][j] = dp[i - 1][j];
        if (j >= nums[i - 1])
        {
            dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i - 1]];
        }
    }
}
```

##### 优化后一维代码片段

```cpp
vector<bool> dp(target + 1, false);
dp[0] = true;

for (int i = 1; i <= n; i++)
{
    for (int j = target; j >= nums[i - 1]; j--)	 // 逆序遍历
    {
        dp[j] = dp[j] || dp[j - nums[i - 1]];
    }
}
```

##### 优化依据总结

1. **空间压缩**：每一行仅依赖前一行，无需保留完整二维状态。  
2. **逆序保证正确性**：防止同一元素被重复选取，严格遵循 0-1 背包规则。  
3. **时间复杂度不变**：仍为 `O(n*target)`，但空间复杂度降为 `O(target)`。

---

#### 五、示例推演（辅助理解）

##### 1. 以 `nums = [1, 2, 5]`，总和 `8`，目标 `4` 为例：

##### 二维 DP 表格（部分）
|      | 0    | 1    | 2    | 3    | 4    |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | T    | F    | F    | F    | F    |
| 1    | T    | T    | F    | F    | F    |
| 2    | T    | T    | T    | T    | F    |
| 3    | T    | T    | T    | T    | F    |

##### 一维 DP 更新过程（逆序）

1. 处理 `nums[0] = 1`：
   - `j=4→1`: `dp[1] = dp[1] || dp[0] → true`  
   - 最终 `dp = [T, T, F, F, F]`  

2. 处理 `nums[1] = 2`：
   - `j=4→2`:  
     - `j=4`: `dp[4] = F || dp[2] → F`  
     - `j=3`: `dp[3] = F || dp[1] → T`  
     - `j=2`: `dp[2] = F || dp[0] → T`  
   - 最终 `dp = [T, T, T, T, F]`  

3. 处理 `nums[2] = 5`（超过 `target=4`，跳过）  
   - 最终 `dp[4] = F` → 返回 `false`。

---

##### 2. 以 `nums = [1, 5, 11, 5]` 为例：

1.  **总和**：`sum = 22` → `target = 11`。
2.  **初始化**：`dp[0] = true`，其他为 `false`。
3.  **遍历过程**：
    -   **处理元素 1**（`i=1`）：
        -   更新 `j=11 → 1`：
            -   `j=1`：`dp[1] = dp[1] || dp[0] = true`。
    -   **处理元素 5**（`i=2`）：
        -   更新 `j=11 → 5`：
            -   `j=5`：`dp[5] = dp[5] || dp[0] = true`。
            -   `j=6`：`dp[6] = dp[6] || dp[1] = true`。
            -   ...
    -   **处理元素 11**（`i=3`）：
        -   更新 `j=11`：`dp[11] = dp[11] || dp[0] = true`。
    -   **最终结果**：`dp[11] = true`。