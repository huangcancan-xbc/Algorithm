### 算法原理

#### 问题描述

给定一个整数数组 `stones`，每次选择两块石头粉碎，若两石重量为 `x` 和 `y`（`x ≤ y`），则粉碎后剩余重量为 `y - x`。重复操作直到剩下一块石头，求最后石头的最小可能重量。

**问题转化与分析**

原始问题涉及将石块两两粉碎，其相同重量的部分会被丢弃，而差异部分会留下来。这可以转化为一个数学或算法问题：

-   **加号和减号的使用**：想象在原有数据前加上加号或者减号，目标是使最终结果最小化。这意味着我们需要将原始石头分成两组，使得这两组的总重量尽可能接近。
-   **接近总和的一半**：当所有元素（即石头的重量）的总和固定时，为了使两个分组之间的差值最小，这两个分组的和应该尽可能接近总和的一半。

基于上述分析，原问题可以被重新定义为：从数组中选择一些数，使其和尽量接近 `sum / 2`。如果将每个数值视为物品的体积和价值，那么这个问题就可以转化为经典的「01 背包问题」。

#### 核心思路：转化为背包问题

1. **问题转化**：  
   - 将石头分为两堆 `A` 和 `B`，使得两堆重量差最小。  
   
   - 设总重量为 `sum`，则差值为 `|sum - 2 * A|`。  
   
       >##### 正确差值的推导
       >
       >1.  **两堆石头的重量**：
       >    -   一堆为 `dp[n][m]` 表示不超过 `sum/2` 的最大子集和（最大子集和）。
       >    -   另一堆为 `sum - dp[n][m]`。
       >    -   `sum - 2 * dp[n][m]` 表示两堆石头的重量差。
       >2.  **差值公式**：
       >    -   两堆的差值为 `|(sum - dp[n][m]) - dp[n][m]| = |sum - 2 * dp[n][m]|`。
       >    -   由于 `dp[n][m]` 是最大子集和且 `dp[n][m] ≤ sum/2`，因此 `sum - 2 * dp[n][m]` 始终非负，绝对值可省略。
       >3.  **直接返回 `sum/2 - dp[n][m]` 的问题**：
       >    -   如果 `dp[n][m]` 恰好等于 `sum/2`，则差值为 `0`，这是正确的结果。
       >    -   但如果 `dp[n][m] < sum/2`，则 `sum/2 - dp[n][m]` 表示的是 `sum/2` 与 `dp[n][m]` 的差值，而不是两堆石头的实际差值。
   
   - **目标**：最大化 `A`（`A ≤ sum/2`），使得 `sum - 2A` 最小。  
   
   - **等价于**：在石头中选出总重量不超过 `sum/2` 的最大子集和（转化为 01 背包问题）。

![image-20250304230737948](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250304230738139.png)

---

### 动态规划设计

#### 1. 状态定义

- `dp[i][j]` 表示前 `i` 块石头中选出总重量不超过 `j` 的最大子集和。  
- **目标**：求 `dp[n][m]`，其中 `m = sum / 2`。

#### 2. 状态转移方程

对于第 `i` 块石头 `stones[i-1]`：  
1. **不选当前石头**：继承前 `i-1` 块石头的状态：`dp[i][j] = dp[i-1][j]`。  
2. **选当前石头**（需满足 `j >= stones[i-1]`）：累加当前石头重量：`dp[i][j] = max(dp[i][j], dp[i-1][j - stones[i-1]] + stones[i-1])`。  

**方程整合**：  
```cpp
dp[i][j] = max(dp[i-1][j], dp[i-1][j - stones[i-1]] + stones[i-1]);
```

#### 3. 初始化

- `dp[0][j] = 0`（没有石头可选，最大和为 0）。  
- `dp[i][0] = 0`（容量为 0，无法装任何石头）。

---

### 空间优化：一维 DP 数组

所有的背包问题，都可以进行「空间」上的优化，对于 01 背包类型的优化策略是：

-   删除第一维。
-   修改第二层循环的「**遍历顺序**」即可。

#### 1. 状态压缩

- 用一维数组 `dp[j]` 代替二维数组，`dp[j]` 表示容量为 `j` 时的最大子集和。  

#### 2. 逆序遍历的必要性

- **正向遍历问题**：若正序更新 `j`，较小的 `j` 值会被当前行覆盖，导致后续 `dp[j - stones[i-1]]` 引用的是当前行的值（错误）。  
- **逆序遍历解决**：从 `m` 到 `stones[i-1]` 逆序更新，确保 `dp[j - stones[i-1]]` 引用的是上一行的状态。  

**优化后的转移方程**：  

```cpp
for (int j = m; j >= stones[i-1]; j--)
{
    dp[j] = max(dp[j], dp[j - stones[i-1]] + stones[i-1]);
}
```

#### 边界条件与验证

1. **所有石头重量相同**：  
   - 例如 `stones = [5,5]`，`sum = 10` → `m = 5`，`dp[5] = 5`，差值为 `10 - 2*5 = 0`。  
2. **无法均分**：  
   - 例如 `stones = [1,2,3,4]`，`sum = 10` → `m = 5`，`dp[5] = 5`，差值为 `0`。  

