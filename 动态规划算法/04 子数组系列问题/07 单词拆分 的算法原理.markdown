### 算法原理

#### 1. 状态表示

定义 `dp[i]` 表示字符串 `s` 的前 `i` 个字符（即 `s[0...i-1]`）是否可以被拆分成字典中的单词。例如，`dp[4] = true` 表示前 4 个字符组成的子串可以被拆分。

**为什么这样设计？**  
我们需要解决的问题是“整个字符串能否被拆分”，而动态规划的核心是将大问题分解为子问题。通过逐字符扩展，逐步判断每个子串是否满足拆分条件。

#### 2. 状态转移方程

对于每个位置 `i`，我们需要检查所有可能的拆分点 `j`（`1 ≤ j ≤ i`），判断以下两个条件是否成立：
- 前 `j-1` 个字符可以拆分（即 `dp[j-1] = true`）；
- 剩余子串 `s[j-1...i-1]` 存在于字典中。

状态转移方程如下：  

```
dp[i] = 存在某个 j ∈ [1, i]，使得 dp[j-1] && (s[j-1...i-1] ∈ wordDict)
```

**如何理解？**  
若存在一个位置 `j`，使得前 `j-1` 个字符可拆分，且剩余部分 `s[j-1...i-1]` 是字典中的单词，则前 `i` 个字符整体可拆分。

#### 3. 初始化

初始化 `dp[0] = true`，表示空字符串可以被拆分。这是为了保证后续逻辑的正确性。例如，当整个字符串 `s` 本身就在字典中时，`j = 1`，此时 `dp[j-1] = dp[0] = true`。

#### 4. 填表顺序

- **外层循环**：按 `i` 从 `1` 到 `n`（字符串长度）遍历，逐步计算每个位置的状态。
- **内层循环**：对于每个 `i`，倒序遍历 `j`（从 `i` 到 `1`）。这是为了优化效率，一旦找到满足条件的 `j`，即可提前终止内层循环。

**为什么倒序遍历 `j`？**  
假设字典中存在较短的单词，倒序可以更快找到满足条件的拆分点，减少不必要的检查。

#### 5. 返回值

最终返回 `dp[n]`，即整个字符串 `s` 是否可以被拆分。

>### 传道解惑
>
>#### Q1：为什么以 `i` 位置为结尾进行拆分？
>
>代码的核心思想是：**对每个位置 `i`，检查是否存在某个分割点 `j`，使得前 `j` 个字符可拆分，且剩余部分 `s[j...i-1]` 是字典中的单词**。
>
>**具体流程：**
>
>- **`i` 的含义**：表示当前处理到字符串的前 `i` 个字符（即 `s[0...i-1]`）。
>- **`j` 的作用**：尝试将前 `i` 个字符分割为两部分：
>    - 第一部分：前 `j-1` 个字符（由 `dp[j-1]` 判断是否可拆分）。
>    - 第二部分：从 `j-1` 到 `i-1` 的子串（检查是否在字典中）。
>- **动态规划的本质**：通过已知的小问题（`dp[j-1]`）的答案，推导大问题（`dp[i]`）的答案。
>
>---
>
>#### Q2：为什么必须更新整个 `dp` 表，而不是中途返回 `false`？
>
>动态规划的核心是**全局依赖**：每个位置 `i` 的状态 `dp[i]` 可能依赖于前面任意位置 `j` 的状态。即使某个位置 `i` 无法被拆分，后续的位置可能仍然存在合法的拆分方式。
>
>**举例说明：**
>假设字符串为 `s = "applepenapple"`，字典为 `["apple", "pen"]`：
>
>- 当 `i = 5`（对应子串 `"apple"`），`dp[5] = true`。
>- 当 `i = 8`（对应子串 `"applepen"`），分割点 `j = 6`，剩余部分 `"pen"` 在字典中，因此 `dp[8] = true`。
>- 当 `i = 13`（整个字符串），分割点 `j = 9`，剩余部分 `"apple"` 在字典中，最终 `dp[13] = true`。
>
>如果在中途（比如 `i = 5` 时）直接返回 `false`，就会错误地认为整个字符串无法拆分，而实际上后续存在合法的拆分路径。
>
>**为什么不能中途返回 `false`？**
>
>动态规划要求**填满所有状态**，因为后续的状态可能依赖于前面任意位置的状态。例如：
>
>- 字符串 `s = "aaaaa"`，字典为 `["a", "aa", "aaa"]`。
>- 即使 `i = 3`（子串 `"aaa"`）时无法拆分（假设字典只有 `"a"` 和 `"aa"`），但 `i = 4` 时可能通过 `j = 2` 分割为 `"aa" + "aa"`，从而使得 `dp[4] = true`。
>
>---
>
>#### 填表顺序的优化
>
>内层循环倒序遍历 `j`（从 `i` 到 `1`）是为了**快速找到有效的拆分点**：
>
>- 假设字典中存在较短的单词（例如 `"a"`），倒序可以更快命中这些单词，减少不必要的遍历。
>- 一旦找到满足条件的 `j`（即 `dp[j-1] = true` 且子串在字典中），立即标记 `dp[i] = true` 并跳出循环，避免冗余计算。
>
>**时间复杂度与空间复杂度**
>
>- **时间复杂度**：`O(n^2)`，因为外层循环遍历 `n` 次，内层循环最坏情况下也遍历 `n` 次。
>- **空间复杂度**：`O(n)`，用于存储 `dp` 数组。
>
>动态规划的 `dp` 表记录了每个子问题的解，这些解共同决定了最终结果。虽然表面上需要遍历所有可能的分割点，但通过倒序优化和提前终止，实际效率往往较高。无法中途返回 `false` 是因为全局状态之间存在依赖，必须完整计算才能确保正确性。

---

#### 详细示例分析

以示例 `s = "catsandog"`，`wordDict = ["cats", "dog", "sand", "and", "cat"]` 来详细展示代码的工作流程。

**初始化**

- 字符串 `s` 的长度为 `n = 9`。
- 将 `wordDict` 中的单词存入哈希集合 `hash`：
  ```cpp
  hash = {"cats", "dog", "sand", "and", "cat"}
  ```
- 初始化 `dp` 数组，大小为 `n + 1 = 10`，所有值初始化为 `false`，除了 `dp[0] = true`：
  ```cpp
  dp = [true, false, false, false, false, false, false, false, false, false]
  ```

---

**填表过程**

我们从 `i = 1` 开始遍历到 `i = 9`，检查每个位置是否可以拆分成字典中的单词。

**i = 1**

- 检查子串 `s[0...0] = "c"`：
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...0] = "c"` 是否在 `hash` 中：不在。
  - 没有找到有效的拆分，`dp[1] = false`。

**更新后的 `dp` 数组**：

```cpp
dp = [true, false, false, false, false, false, false, false, false, false]
```

---

**i = 2**

- 检查子串 `s[0...1] = "ca"`：
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...1] = "ca"` 是否在 `hash` 中：不在。
  - 没有找到有效的拆分，`dp[2] = false`。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, false, false, false, false, false, false, false]
```

---

**i = 3**

- 检查子串 `s[0...2] = "cat"`：
  - `j = 3`：
    - `dp[j-1] = dp[2] = false`。
    - 跳过。
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...2] = "cat"` 是否在 `hash` 中：在。
    - 因此，`dp[3] = true`。
    - 退出内层循环。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, false, false, false, false, false, false]
```

---

**i = 4**

- 检查子串 `s[0...3] = "cats"`：
  - `j = 4`：
    - `dp[j-1] = dp[3] = true`。
    - 检查 `s[3...3] = "s"` 是否在 `hash` 中：不在。
  - `j = 3`：
    - `dp[j-1] = dp[2] = false`。
    - 跳过。
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...3] = "cats"` 是否在 `hash` 中：在。
    - 因此，`dp[4] = true`。
    - 退出内层循环。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, true, false, false, false, false, false]
```

---

**i = 5**

- 检查子串 `s[0...4] = "catsa"`：
  - `j = 5`：
    - `dp[j-1] = dp[4] = true`。
    - 检查 `s[4...4] = "a"` 是否在 `hash` 中：不在。
  - `j = 4`：
    - `dp[j-1] = dp[3] = true`。
    - 检查 `s[3...4] = "sa"` 是否在 `hash` 中：不在。
  - `j = 3`：
    - `dp[j-1] = dp[2] = false`。
    - 跳过。
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...4] = "catsa"` 是否在 `hash` 中：不在。
  - 没有找到有效的拆分，`dp[5] = false`。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, true, false, false, false, false, false]
```

---

**i = 6**

- 检查子串 `s[0...5] = "catsan"`：
  - `j = 6`：
    - `dp[j-1] = dp[5] = false`。
    - 跳过。
  - `j = 5`：
    - `dp[j-1] = dp[4] = true`。
    - 检查 `s[4...5] = "an"` 是否在 `hash` 中：不在。
  - `j = 4`：
    - `dp[j-1] = dp[3] = true`。
    - 检查 `s[3...5] = "san"` 是否在 `hash` 中：不在。
  - `j = 3`：
    - `dp[j-1] = dp[2] = false`。
    - 跳过。
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...5] = "catsan"` 是否在 `hash` 中：不在。
  - 没有找到有效的拆分，`dp[6] = false`。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, true, false, false, false, false, false]
```

---

**i = 7**

- 检查子串 `s[0...6] = "catsand"`：
  - `j = 7`：
    - `dp[j-1] = dp[6] = false`。
    - 跳过。
  - `j = 6`：
    - `dp[j-1] = dp[5] = false`。
    - 跳过。
  - `j = 5`：
    - `dp[j-1] = dp[4] = true`。
    - 检查 `s[4...6] = "and"` 是否在 `hash` 中：在。
    - 因此，`dp[7] = true`。
    - 退出内层循环。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, true, false, false, true, false, false]
```

---

**i = 8**

- 检查子串 `s[0...7] = "catsando"`：
  - `j = 8`：
    - `dp[j-1] = dp[7] = true`。
    - 检查 `s[7...7] = "o"` 是否在 `hash` 中：不在。
  - `j = 7`：
    - `dp[j-1] = dp[6] = false`。
    - 跳过。
  - `j = 6`：
    - `dp[j-1] = dp[5] = false`。
    - 跳过。
  - `j = 5`：
    - `dp[j-1] = dp[4] = true`。
    - 检查 `s[4...7] = "ando"` 是否在 `hash` 中：不在。
  - `j = 4`：
    - `dp[j-1] = dp[3] = true`。
    - 检查 `s[3...7] = "sando"` 是否在 `hash` 中：不在。
  - `j = 3`：
    - `dp[j-1] = dp[2] = false`。
    - 跳过。
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...7] = "catsando"` 是否在 `hash` 中：不在。
  - 没有找到有效的拆分，`dp[8] = false`。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, true, false, false, true, false, false]
```

---

**i = 9**

- 检查子串 `s[0...8] = "catsandog"`：
  - `j = 9`：
    - `dp[j-1] = dp[8] = false`。
    - 跳过。
  - `j = 8`：
    - `dp[j-1] = dp[7] = true`。
    - 检查 `s[7...8] = "og"` 是否在 `hash` 中：不在。
  - `j = 7`：
    - `dp[j-1] = dp[6] = false`。
    - 跳过。
  - `j = 6`：
    - `dp[j-1] = dp[5] = false`。
    - 跳过。
  - `j = 5`：
    - `dp[j-1] = dp[4] = true`。
    - 检查 `s[4...8] = "andog"` 是否在 `hash` 中：不在。
  - `j = 4`：
    - `dp[j-1] = dp[3] = true`。
    - 检查 `s[3...8] = "sandog"` 是否在 `hash` 中：不在。
  - `j = 3`：
    - `dp[j-1] = dp[2] = false`。
    - 跳过。
  - `j = 2`：
    - `dp[j-1] = dp[1] = false`。
    - 跳过。
  - `j = 1`：
    - `dp[j-1] = dp[0] = true`。
    - 检查 `s[0...8] = "catsandog"` 是否在 `hash` 中：不在。
  - 没有找到有效的拆分，`dp[9] = false`。

**更新后的 `dp` 数组**：
```cpp
dp = [true, false, false, true, true, false, false, true, false, false]
```

---

**返回值**

最终返回 `dp[9] = false`，表示字符串 `s = "catsandog"` 不能被拆分成字典中的单词。
