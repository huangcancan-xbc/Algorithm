### 算法原理

**问题分析**  
题目要求统计数组中所有长度至少为3的等差数列子数组的数量。关键在于如何高效计算连续等差子数组的个数，避免重复计算。

**动态规划状态定义**  
- **`dp[i]`**：表示以第 `i` 个元素（数组索引 `i`）结尾的等差数列子数组的个数。  例如，若 `nums[0...i]` 是一个等差数列，则 `dp[i]` 记录的是以 `i` 结尾的所有满足条件的子数组数目。

**状态转移方程**  
- **当 `nums[i]` 与前两个元素构成等差关系时**（即 `nums[i] - nums[i-1] == nums[i-1] - nums[i-2]`）：  
  - 此时，以 `i` 结尾的等差数列子数组的个数为 `dp[i-1] + 1`。  
  - 新增的子数组是**以 `i-1` 结尾的所有等差子数组的扩展**，加上**仅包含最后三个元素的新子数组**。  
- **否则**：  无法形成新的等差子数组，`dp[i] = 0`。

**数学形式**：  

$dp[i] = 
\begin{cases} 
dp[i-1] + 1 & \text{if } nums[i] - nums[i-1] = nums[i-1] - nums[i-2] \\
0 & \text{otherwise}
\end{cases}$

**初始化**  

- `dp[0] = 0`, `dp[1] = 0`：因为至少需要三个元素才能构成等差数列。
- 从 `i = 2`（第三个元素）开始计算。

**填表顺序**  
- **从左到右**遍历数组，从第三个元素开始（索引 `i=2`），逐步计算每个位置的 `dp[i]`。

**返回值**  
- 将所有的 `dp[i]` 累加，得到所有可能的等差子数组的总数。
