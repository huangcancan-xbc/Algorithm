### 算法原理

**问题描述**：给定一个由不同整数组成的数组 `nums` 和一个目标整数 `target`，计算所有可能的排列数，使得这些数的和等于 `target`（元素可重复使用，不同顺序视为不同排列）。

**注意事项**

- 本题本质上求的是「排列数」问题，而非背包问题中的「组合」数问题。
- 需要采用动态规划（DP）的思想来解决。
- 本题的测试样例中含有非常大的样例，超过 `long long` 的范围，因此，我们使用 `double` 来避免溢出。

![image-20250306171440908](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250306171441185.png)

---

#### 1. 状态表示

抽象出的状态表示基于如何拆分出相同子问题：

- 当计算目标值 `target` 共有多少种排列方式时，对于最后一个位置，如果我们选择数组中的一个数 `x`，那么接下来就是寻找 `target - x` 有多少种排列方式。
- 因此，状态表示为：`dp[i]` 表示总和为 `i` 的时候，一共有多少种排列方案。

#### 2. 状态转移方程

- 对于 `dp[i]`，根据最后一个位置划分，可以选择数组中的任意一个数 `nums[j]`，其中 `0 <= j <= n - 1`。
- 当 `nums[j] <= target` 时，此时的排列数等于我们先找到 `target - nums[j]` 的方案数，然后在每一个方案后面加上一个数字 `nums[j]`。
- 由于有多个 `j` 符合情况，因此状态转移方程为：`dp[i] += dp[target - nums[j]]`，其中 `0 <= j <= n - 1`。

#### 3. 初始化

- 当和为 `0` 的时候，可以什么都不选，“空集”一种方案，因此 `dp[0] = 1`（凑出总和 0 有 1 种方式 —— 空集合）。

#### 4. 填表顺序

根据状态转移方程得出填表顺序应为“**从左往右**”：

- **外层遍历总和**：从 `1` 到 `target`，确保每个 `i` 依赖更小的 `i - x` 的结果。
- **内层遍历数字**：遍历 `nums` 中的每个元素 `x`，允许任意顺序组合。

#### 5. 返回值

- 根据状态表示，返回值是 `dp[target]` 的值。