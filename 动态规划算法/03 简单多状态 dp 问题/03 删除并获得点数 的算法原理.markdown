## 算法原理

其实这道题依旧是「打家劫舍I」问题的变型。   

我们注意到题目的描述，选择 $ x $ 数字的时候，$ x - 1 $ 与 $ x + 1 $ 是不能被选择的。像不像「打家劫舍」问题中，选择第 $ i $ 位置的金额之后，就不能选择 $ i - 1 $ 位置以及 $ i + 1 $ 位置的金额呢？ 

因此，我们可以创建一个大小为 10001（根据题目的数据范围）的 hash 数组，将 nums 数组中每一个元素 $ x $，累加到 hash 数组下标为 $ x $ 的位置处，然后在 hash 数组上来一次「打家劫舍」即可。

### 1. 状态表示

我们需要定义两个状态：

-   `f[i]`：表示选择数字 `i` 时的最大点数。
-   `g[i]`：表示不选择数字 `i` 时的最大点数。

因为如果选择数字 `i`，那么数字 `i-1` 不能被选；如果不选择数字 `i`，那么可以自由选择 `i-1` 或者不选。

### 2. 状态转移方程

-   **选择数字 `i` 时**：如果我们选择数字 `i`，那么我们必须跳过 `i-1`，这时最大点数是 `g[i-1] + arr[i]`。这里 `arr[i]` 表示所有数字 `i` 的累计点数。
    -   公式：`f[i] = g[i-1] + arr[i]`
-   **不选择数字 `i` 时**：如果我们不选择数字 `i`，则可以选择 `i-1`，或者不选择 `i-1`，所以最大点数是 `max(g[i-1], f[i-1])`。
    -   公式：`g[i] = max(g[i-1], f[i-1])`

### 3. 初始化

-   **初始化 `arr[]`**：我们在开始时对 `arr[]` 数组进行初始化，它的大小是 `10001`，用于统计每个数字出现的总点数（即每个数字出现多少次，将它们的值相加）。初始时，`arr[i] = 0`，表示没有任何数字出现。
-   **初始化 `f[]` 和 `g[]`**：`f[0]` 和 `g[0]` 的初值应该是 `0`，表示没有任何数字时的最大点数为 `0`。
    -   `f[0]` 表示“选择数字 0”时的最大点数，但因为数字 0 不存在，所以 `f[0] = 0`。
    -   `g[0]` 表示“不选择数字 0”时的最大点数，同样 `g[0] = 0`。

### 4. 填表顺序

我们从 `i = 1` 开始填表，直到 `i = 10000`（题目规定的最大值），逐步根据状态转移方程计算每个位置的 `f[i]` 和 `g[i]`。

-   从 `i = 1` 到 `i = 10000`，我们按顺序填充 `f[i]` 和 `g[i]` 的值，因为每个位置的状态依赖于前一个位置的状态。

### 5. 返回值

最终答案是 `max(f[n-1], g[n-1])`，其中 `n = 10001`。这两个值代表了：

-   `f[n-1]`：表示选择数字 `10000` 时的最大点数。
-   `g[n-1]`：表示不选择数字 `10000` 时的最大点数。

我们要返回的是这两者的较大值，表示选择或不选择数字 `10000` 后得到的最大点数。