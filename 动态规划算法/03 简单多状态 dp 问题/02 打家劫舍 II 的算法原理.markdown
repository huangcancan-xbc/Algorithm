## 算法原理

### 1. 状态表示

#### 方法一：使用辅助函数 `rob1`

- **状态定义**：
  - `f[i]`：表示打劫到第 `i` 间房屋时，**选择打劫第 `i` 间房屋**后的最大金额。
  - `g[i]`：表示打劫到第 `i` 间房屋时，**不选择打劫第 `i` 间房屋**后的最大金额。

#### 方法二：不使用辅助函数

- **状态定义**：
  - **`f[i]`**：在**不打劫第一个房屋**的情况下，打劫到第 `i` 间房屋时的最大金额（范围为 `[1, n-1]`）。
  - **`g[i]`**：在**打劫第一个房屋**的情况下，打劫到第 `i` 间房屋时的最大金额（范围为 `[0, n-2]`，且必须确保不打劫最后一个房屋）。

---

### 2. 状态转移方程

#### 方法一：使用辅助函数 `rob1`
- **选择打劫第 `i` 间房屋 (`f[i]`)**：
  - 如果选择打劫第 `i` 间房屋，那么第 `i-1` 间房屋**不能打劫**。
  - 因此，`f[i]` 的值取决于不选择第 `i-1` 间房屋时的最大金额，再加上第 `i` 间房屋的金额。
  - 状态转移方程为：==$f[i] = g[i - 1] + nums[i]$==
  
- **不选择打劫第 `i` 间房屋 (`g[i]`)**：
  - 如果不选择打劫第 `i` 间房屋，那么第 `i-1` 间房屋**可以选择打劫或不打劫**。
  - 因此，`g[i]` 的值取决于选择或不选择第 `i-1` 间房屋时的最大金额中的较大值。
  - 状态转移方程为：==$g[i] = \max(f[i - 1], g[i - 1])$==

#### 方法二：不使用辅助函数
- **不打劫第一个房屋 (`f[i]`)**：
  -   ==$f[i] = max(f[i-1], f[i-2] + nums[i]$)==（标准打家劫舍问题）。
  
- **打劫第一个房屋 (`g[i]`)**：
    -   ==$g[i] = max(g[i-1], g[i-2] + nums[i])$== （确保不触发相邻规则，且 `i` 不超过 `n-2`）。

---

### 3. 初始化

#### 方法一：使用辅助函数 `rob1`
- **初始化**：
  - `f[left] = nums[left]`：如果选择打劫第 `left` 间房屋，获得的金额就是 `nums[left]`。
  - `g[left] = 0`：如果不选择打劫第 `left` 间房屋，获得的金额为 `0`。

#### 方法二：不使用辅助函数
- **初始化**：
  - **不打劫第一个房屋 (`f[i]`)**：
    -   `f[1] = nums[1]`（从第二间房屋开始打劫）。
    -   `f[2] = max(nums[1], nums[2])`（第二间和第三间不可同时打劫）。
  - **打劫第一个房屋 (`g[i]`)**：
      -   `g[0] = nums[0]`（必须打劫第一个房屋）。
      -   `g[1] = nums[0]`（不能打劫第二个房屋，只能继承 `g[0]`）。

---

### 4. 填表顺序

#### 方法一：使用辅助函数 `rob1`
- **填表顺序**：
  - 从左到右依次计算 `f[i]` 和 `g[i]`，因为每个状态 `f[i]` 和 `g[i]` 都依赖于前一个状态 `f[i-1]` 和 `g[i-1]`。

#### 方法二：不使用辅助函数
- **填表顺序**：
  - 从左到右依次计算 `f[i]` 和 `g[i]`，因为每个状态 `f[i]` 和 `g[i]` 都依赖于前一个状态 `f[i-1]` 和 `f[i-2]` 或 `g[i-1]` 和 `g[i-2]`。

---

### 5. 返回值

#### 方法一：使用辅助函数 `rob1`
- **返回值**：
  - 返回两种情况的最大值：
    - 不打劫第一个房屋，打劫到第 `n-1` 间房屋的最大金额：`rob1(nums, 1, n - 1)`。
    - 打劫第一个房屋，不打劫最后一个房屋，打劫到第 `n-2` 间房屋的最大金额：`nums[0] + rob1(nums, 2, n - 2)`。

#### 方法二：不使用辅助函数
- **返回值**：
  - 返回两种情况的最大值：
    - 不打劫第一个房屋，打劫到第 `n-1` 间房屋的最大金额：`f[n - 1]`。
    - 打劫第一个房屋，不打劫最后一个房屋，打劫到第 `n-2` 间房屋的最大金额：`g[n - 2]`。

---

### 小结

#### 方法一：使用辅助函数 `rob1`

- 通过将问题分解为两个子问题（不打劫第一个房屋和打劫第一个房屋），分别调用 `rob1` 函数解决。
- 状态转移方程清晰，代码结构简洁。

#### 方法二：不使用辅助函数

- 直接通过两个数组 `f` 和 `g` 记录状态，避免了重复调用函数。
- 需要处理更多的边界条件（如 `n == 1` 和 `n == 2` 的情况）。
