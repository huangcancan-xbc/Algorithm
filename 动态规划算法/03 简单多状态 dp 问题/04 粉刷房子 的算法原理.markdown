### 算法原理

#### 1. 状态表示

对于线性 dp，我们可以用「经验 + 题目要求」来定义状态表示：
- i. 以某个位置为结尾，巴拉巴拉；
- ii. 以某个位置为起点，巴拉巴拉。
这里我们选择比较常用的方式，以某个位置为结尾，结合题目要求，定义一个状态表示。但是我们这个题在 i 位置的时候，会面临「红」「蓝」「绿」三种抉择，所依赖的状态需要细分：
- `dp[i][0]` 表示：粉刷到 i 位置的时候，最后一个位置粉刷上「红色」，此时的最小花费；
- `dp[i][1]` 表示：粉刷到 i 位置的时候，最后一个位置粉刷上「蓝色」，此时的最小花费；
- `dp[i][2]` 表示：粉刷到 i 位置的时候，最后一个位置粉刷上「绿色」，此时的最小花费。

#### 2. 状态转移方程
因为状态表示定义了三个，因此我们的状态转移方程也要分析三个：
对于 `dp[i][0]`：
- 如果第 i 个位置粉刷上「红色」，那么 i - 1 位置上可以是「蓝色」或者「绿色」。因此我们需要知道粉刷到 i - 1 位置上的时候，粉刷上「蓝色」或者「绿色」的最小花费，然后加上 i 位置的花费即可。于是状态转移方程为：`dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + costs[i - 1][0];`
同理，我们可以推导出另外两个状态转移方程为：
- `dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + costs[i - 1][1];`
- `dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + costs[i - 1][2];`

#### 3. 初始化
可以在最前面加一个「辅助结点」，帮助我们初始化。使用这种技巧要注意两个点：
- i. 辅助结点里面的值要「保证后续填表是正确的」；
- ii. 「下标的映射关系」。
在本题中，添加一个节点，并且初始化为 0 即可。

#### 4. 填表顺序
根据「状态转移方程」得「从左往右，三个表一起填」。

#### 5. 返回值
根据「状态表示」，应该返回最后一个位置粉刷上三种颜色情况下的最小值，因此需要返回：`min(dp[n][0], min(dp[n][1], dp[n][2]))`。