## 算法原理

### 1. 状态表示

对于简单的线性动态规划问题，我们可以用“经验 + 题目要求”来定义状态表示：

- i. 以某个位置为结尾；
- ii. 以某个位置为起点。

这里我们选择比较常用的方式，以某个位置为结尾，结合题目要求，定义一个状态表示：

`dp[i]` 表示：选择到 `i` 位置时，此时的最长预约时长。但是这个问题在 `i` 位置的时候，会面临“选择”或者“不选择”两种抉择，所依赖的状态需要细分：

- `f[i]` 表示：选择到 `i` 位置时，`nums[i]` 必选，此时的最长预约时长；
- `g[i]` 表示：选择到 `i` 位置时，`nums[i]` 不选，此时的最长预约时长。

### 2. 状态转移方程

因为状态表示定义了两个，因此我们的状态转移方程也要分析两个：

- 对于 `f[i]`：
  - 如果 `nums[i]` 必选，那么我们仅需知道 `i - 1` 位置在不选的情况下的最长预约时长，然后加上 `nums[i]` 即可，因此 `f[i] = g[i - 1] + nums[i]`。
  
- 对于 `g[i]`：
  - 如果 `nums[i]` 不选，那么 `i - 1` 位置上选或者不选都可以。因此，我们需要知道 `i - 1` 位置上选或者不选两种情况下的最长时长，因此 `g[i] = max(f[i - 1], g[i - 1])`。

>通俗理解：
>
>-   选择第 `i` 次按摩 (`f[i]`)
>    -   如果选择第 `i` 次按摩，那么第 `i-1` 次按摩**不能选择**。因此，`f[i]` 的值取决于不选择第 `i-1` 次按摩时的最大时长，再加上第 `i` 次按摩的时长。状态转移方程为：$f[i] = g[i - 1] + nums[i]$
>-   不选择第 `i` 次按摩 (`g[i]`)
>    -   如果不选择第 `i` 次按摩，那么第 `i-1` 次按摩**可以选择或不选择**。因此，`g[i]` 的值取决于选择或不选择第 `i-1` 次按摩时的最大时长中的较大值。状态转移方程为：$g[i] = \max(f[i - 1], g[i - 1])$
>

### 3. 初始化

这道题的初始化比较简单，因此无需加辅助节点

对于第 `0` 次按摩：

- 如果选择第 `0` 次按摩，`f[0] = nums[0]`。
- 如果不选择第 `0` 次按摩，`g[0] = 0`。

### 4. 填表顺序

根据状态转移方程，我们需要从左到右依次计算 `f[i]` 和 `g[i]`。因为每个状态 `f[i]` 和 `g[i]` 都依赖于前一个状态 `f[i-1]` 和 `g[i-1]`，所以填表顺序是“从左往右，两个表一起填”。

### 5. 返回值

最终的结果是选择或不选择最后一次按摩时的最大时长，根据“状态表示”，应该返回 `max(f[n - 1], g[n - 1])`。

---

**示例说明：**

假设输入数组为 `nums = [1, 2, 3, 1]`，我们通过状态转移方程来计算 `f[i]` 和 `g[i]`。

**初始化：**

- `f[0] = nums[0] = 1`
- `g[0] = 0`

**计算过程：**

1. **第 1 次按摩 (`i = 1`)**：
   - 选择第 1 次按摩：`f[1] = g[0] + nums[1] = 0 + 2 = 2`
   - 不选择第 1 次按摩：`g[1] = max(f[0], g[0]) = max(1, 0) = 1`

2. **第 2 次按摩 (`i = 2`)**：
   - 选择第 2 次按摩：`f[2] = g[1] + nums[2] = 1 + 3 = 4`
   - 不选择第 2 次按摩：`g[2] = max(f[1], g[1]) = max(2, 1) = 2`

3. **第 3 次按摩 (`i = 3`)**：
   - 选择第 3 次按摩：`f[3] = g[2] + nums[3] = 2 + 1 = 3`
   - 不选择第 3 次按摩：`g[3] = max(f[2], g[2]) = max(4, 2) = 4`

**最终结果：**选择或不选择最后一次按摩的最大时长为 `max(f[3], g[3]) = max(3, 4) = 4`。

