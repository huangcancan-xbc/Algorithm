### 算法原理

#### 1. 核心思想

本问题要求找到数组中最长的斐波那契子序列。斐波那契子序列定义为满足 `X_{k} = X_{k-1} + X_{k-2}` 的序列，且长度至少为 3。通过 **动态规划** 结合 **哈希表优化**，可以高效解决该问题。

#### 2. 动态规划状态定义
- **`dp[i][j]`**：表示以 `arr[i]` 和 `arr[j]` 为最后两个元素的最长斐波那契子序列的长度。例如，`dp[2][4] = 4` 表示存在一个长度为 4 的子序列，最后两个元素是 `arr[2]` 和 `arr[4]`。

#### 3. 状态转移方程

对于每个 `j`（当前子序列最后一个元素）和 `i`（倒数第二个元素）：
- 计算前驱值 `a = arr[j] - arr[i]`。
- 若 `a` 存在于数组中且 `a < arr[i]`（保证顺序），则找到其索引 `k`，并更新状态：`dp[i][j] = dp[k][i] + 1`。表示将 `arr[j]` 接在以 `arr[k]` 和 `arr[i]` 结尾的子序列之后，长度增加 1。

#### 4. 哈希表优化原理

- **快速查找前驱**：哈希表存储元素值到索引的映射，允许在 O(1) 时间内判断 `a` 是否存在并获取其位置。
- **剪枝条件**：通过 `a < arr[i]` 确保前驱元素 `a` 的索引 `k` 位于 `i` 之前，避免无效遍历。

#### 5. 初始化与边界条件
- **初始化**：所有 `dp[i][j]` 初始化为 2，因为任意两个元素均可视为长度为 2 的“初始序列”。
- **结果处理**：若最终最长序列长度小于 3，返回 0（题目要求长度至少为 3）。

---

### 示例分析（以 `arr = [1,2,3,4,5,6,7,8]` 为例）

1. **哈希表构建**：存储每个元素及其索引，如 `hash[1]=0`, `hash[2]=1`, ..., `hash[8]=7`。
2. **动态规划过程**：
   - **j = 2（元素 3）**：
     - i = 1（元素 2），a = 3-2 = 1，存在且 a < 2 → `dp[1][2] = dp[0][1] + 1 = 3`（序列 `[1,2,3]`）。
   - **j = 4（元素 5）**：
     - i = 2（元素 3），a = 5-3 = 2，存在且 a < 3 → `dp[2][4] = dp[1][2] + 1 = 4`（序列 `[1,2,3,5]`）。
   - **j = 7（元素 8）**：
     - i = 4（元素 5），a = 8-5 = 3，存在且 a < 5 → `dp[4][7] = dp[2][4] + 1 = 5`（序列 `[1,2,3,5,8]`）。
3. **最终结果**：最长斐波那契子序列长度为 5。

---

### 复杂度分析
- **时间复杂度**：O(n²)，双重循环遍历所有元素对。
- **空间复杂度**：O(n²)，存储二维动态规划数组。
