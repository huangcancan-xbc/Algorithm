### 算法原理

#### 1. 状态表示

- **`len[i]`**：表示以 `nums[i]` 为结尾的最长递增子序列（LIS）的长度。
- **`count[i]`**：表示以 `nums[i]` 为结尾的最长递增子序列的个数。

#### 2. 状态转移方程

对于每个元素 `i`，遍历其之前的所有元素 `j`（`0 ≤ j < i`）：
- **情况一**：`nums[j] < nums[i]`（可以形成递增序列）：
  - 如果 `len[j] + 1 > len[i]`：说明发现更长的子序列，更新 `len[i] = len[j] + 1`，并将 `count[i]` 设为 `count[j]`。
  - 如果 `len[j] + 1 == len[i]`：说明存在其他路径形成相同长度的子序列，将 `count[i]` 累加 `count[j]`。

#### 3. 初始化

- 每个元素自身构成长度为 1 的子序列，因此初始化 `len` 数组全为 1，`count` 数组全为 1。

#### 4. 填表顺序

- **外层循环**：从左到右遍历每个元素 `i`（从 1 到 n-1）。
- **内层循环**：对于每个 `i`，遍历其之前的所有元素 `j`（从 0 到 i-1）。

#### 5. 返回值
- 维护全局变量 `retlen`（最长递增子序列长度）和 `retcount`（对应的数量）。遍历过程中不断更新这两个值，最终返回 `retcount`。
