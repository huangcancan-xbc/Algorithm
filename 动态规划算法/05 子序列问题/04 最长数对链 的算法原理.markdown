### 算法原理

#### 1. 状态表示

- **`dp[i]`**：表示以第 `i` 个数对为结尾的最长数对链的长度。例如，`dp[i] = 3` 表示存在一个长度为 3 的链，且最后一个数对是 `pairs[i]`。

#### 2. 状态转移方程
对于每个数对 `i`，遍历其之前的所有数对 `j`（`0 ≤ j < i`）：
- **条件**：若 `pairs[j][1] < pairs[i][0]`（即 `j` 的右端点严格小于 `i` 的左端点），则可以将 `i` 接在 `j` 的链之后。
- **转移**：`dp[i] = max(dp[i], dp[j] + 1)`。这意味着，若通过 `j` 可以形成更长的链，则更新 `i` 的链长度。

#### 3. 初始化
- 每个数对自身可以单独构成长度为 1 的链，因此 `dp` 数组初始化为全 1。

#### 4. 填表顺序
- **外层循环**：从左到右遍历每个数对 `i`（从 1 到 n-1）。
- **内层循环**：对于每个 `i`，遍历其之前的所有数对 `j`（从 0 到 i-1）。这种顺序确保在处理 `i` 时，所有 `j < i` 的 `dp[j]` 已计算完成。

#### 5. 返回值
- 遍历 `dp` 数组，取最大值作为最终结果，即最长链的长度。
