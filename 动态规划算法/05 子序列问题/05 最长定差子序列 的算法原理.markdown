### 算法原理

#### 1. 核心思想

本问题要求找到最长的等差子序列，且等差值为固定的 `difference`。由于子序列不要求连续，但必须保持顺序，因此可以通过 **动态规划** 结合 **哈希表优化** 来高效解决。

#### 2. 动态规划状态定义
- **`hash[key]`**：表示以数值 `key` 为结尾的最长定差子序列的长度。例如，`hash[5] = 3` 表示存在一个长度为 3 的子序列，且最后一个元素是 5。

#### 3. 状态转移方程
对于当前元素 `arr[i]`：
- 计算其前驱值 `prev = arr[i] - difference`。
- 若 `prev` 存在于哈希表中，则当前子序列可以延续 `prev` 对应的最长子序列，即：`hash[arr[i]] = hash[prev] + 1`。
- 若 `prev` 不存在，则当前元素单独构成长度为 1 的子序列，即：`hash[arr[i]] = 1`。

#### 4. 哈希表优化原理

- **快速查找前驱**：哈希表允许在 O(1) 时间内查询 `prev` 是否存在，并直接获取其对应的最长子序列长度，避免了传统动态规划中遍历前面所有元素的 O(n²) 复杂度。
- **覆盖更新策略**：如果多个相同数值的元素出现，哈希表会记录最新遇到的该数值的最长子序列长度。由于子序列需要保持顺序，后续元素只能接在最近的合法前驱之后，因此覆盖更新不会影响正确性。

#### 5. 示例分析
以 `arr = [1,5,7,8,5,3,4,2,1]`, `difference = -2` 为例：
1. **初始化**：`hash[1] = 1`。
2. **处理元素 5**：`prev = 5 - (-2) = 7`（不存在），`hash[5] = 1`。
3. **处理元素 7**：`prev = 7 - (-2) = 9`（不存在），`hash[7] = 1`。
4. **处理元素 8**：`prev = 10`（不存在），`hash[8] = 1`。
5. **处理元素 5**：`prev = 5 - (-2) = 7`（存在且 `hash[7] = 1`），`hash[5] = 1 + 1 = 2`。
6. **处理元素 3**：`prev = 3 - (-2) = 5`（存在且 `hash[5] = 2`），`hash[3] = 2 + 1 = 3`。
7. **处理元素 4**：`prev = 4 - (-2) = 6`（不存在），`hash[4] = 1`。
8. **处理元素 2**：`prev = 2 - (-2) = 4`（存在且 `hash[4] = 1`），`hash[2] = 1 + 1 = 2`。
9. **处理元素 1**：`prev = 1 - (-2) = 3`（存在且 `hash[3] = 3`），`hash[1] = 3 + 1 = 4`。

最终最长子序列为 `[7,5,3,1]`，长度为 4。

---

### 复杂度分析

- **时间复杂度**：O(n)，仅需一次遍历。
- **空间复杂度**：O(n)，哈希表存储每个数值的最优解。
