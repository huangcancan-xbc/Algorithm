### 算法原理

#### 1. 状态表示

- **定义**：`dp[j][i]` 表示以 `nums[j]` 和 `nums[i]` 作为最后两个元素的等差子序列的个数（子序列长度至少为 3）。
- **物理意义**：`dp[j][i]` 的值由所有满足 `nums[k] + nums[i] = 2 * nums[j]`（即 `nums[k]`, `nums[j]`, `nums[i]` 构成等差数列）的 `k`（`k < j`）贡献而来。

#### 2. 状态转移方程

- **公式**：  

$$
dp [j][i] = \sum_{\substack{k < j \\ \text{nums}[k] = 2 \cdot \text{nums}[j] - \text{nums}[i]}} (dp [k][j] + 1)
$$

- **解释**：  当存在 `k < j` 使得 `nums[k]`, `nums[j]`, `nums[i]` 成等差数列时：
  1. `dp[k][j]` 表示以 `k` 和 `j` 结尾的序列数目，这些序列可以扩展为以 `j` 和 `i` 结尾的更长序列。
  2. `+1` 表示新增一个长度为 3 的序列 `(k, j, i)`。

#### 3. 初始化

- **初始值**：所有 `dp[j][i]` 初始化为 0，表示初始时不存在符合条件的子序列。
- **隐含条件**：仅当至少存在三元组 `(k, j, i)` 时，`dp[j][i]` 才会被更新。

#### 4. 填表顺序

- **外层循环**：`i` 从 2 到 `n-1`（第三个元素开始）。
- **内层循环**：`j` 从 1 到 `i-1`（确保 `j < i`）。
- **逻辑**：保证在处理 `dp[j][i]` 时，所有可能的 `k < j` 已被处理，`dp[k][j]` 已知。

#### 5. 返回值

- **累计求和**：最终返回所有 `dp[j][i]` 的和 `sum`，即所有长度 ≥3 的等差子序列总数。

---

#### 关键优化点

- **哈希表加速**：通过哈希表快速查找可能的 `k`，避免遍历所有历史数据。
- **剪枝**：遍历哈希表时，仅处理 `k < j` 的索引，确保逻辑正确性。

#### 复杂度分析

- **时间复杂度**：O(n² * K)，其中 K 为哈希表中每个数值的平均索引数。最坏情况下为 O(n³)。
- **空间复杂度**：O(n²)（存储 `dp` 数组） + O(n)（哈希表）。

#### 示例说明

以数组 `[2, 4, 6, 8]` 为例：
- `i=2`（元素 6），`j=1`（元素 4），计算 `a=2*4-6=2`，找到 `k=0`，更新 `dp[1][2] = 1`（序列 `(0,1,2)`）。
- `i=3`（元素 8），`j=2`（元素 6），计算 `a=2*6-8=4`，找到 `k=1`，更新 `dp[2][3] = dp[1][2] + 1 = 2`（序列 `(0,1,2,3)` 和 `(1,2,3)`）。
- 最终总和为 `1 + 2 = 3`，对应 3 个等差子序列。