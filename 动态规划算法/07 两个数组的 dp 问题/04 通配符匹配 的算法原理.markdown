### 算法原理

**问题描述**：给定字符串 `s` 和包含通配符 `?` 和 `*` 的模式 `p`，判断 `s` 是否匹配 `p`。  

- `?` 匹配任意单个字符。  
- `*` 匹配任意字符串（包括空串）。  

**动态规划解法**：使用二维数组 `dp[i][j]` 表示 **`s` 的前 `i` 个字符** 与 **`p` 的前 `j` 个字符** 是否匹配。

![img](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250302215716464.png)

#### 1. 状态表示

- `dp[i][j]`：布尔值，表示 `s` 的前 `i` 个字符与 `p` 的前 `j` 个字符是否匹配。

#### 2. 状态转移方程

根据 `p` 的当前字符 `p[j-1]` 分类讨论：  
- **当 `p[j-1] = '*'` 时**：  
  
  - `*` 可以匹配空字符（忽略 `*`）：`dp[i][j] = dp[i][j-1]`。  
  - `*` 可以匹配当前字符及之前的字符：`dp[i][j] = dp[i-1][j]`。  
  - 综上：`dp[i][j] = dp[i][j-1] || dp[i-1][j]`。  
  
  >在动态规划中，当模式 `p` 的当前字符为 `*` 时，状态转移方程 `dp[i][j] = dp[i][j-1] || dp[i-1][j]` 的第二个分支 `dp[i-1][j]` 对应 `*` **匹配当前字符及之前的字符**。以下是详细的数学和状态转移的论证：
  >
  >#### 1. 动态规划状态定义
  >
  >- 定义 `dp[i][j]` 为布尔值，表示字符串 `s` 的前 `i` 个字符与模式 `p` 的前 `j` 个字符是否匹配。
  >
  >#### 2. `*` 的两种匹配规则
  >
  >通配符 `*` 可以匹配 **任意长度的字符串（包括空串）**，因此有两种情况：
  >1. **匹配空字符**（忽略 `*`）：  
  >
  >      - 此时 `*` 不参与匹配，直接跳过。  
  >
  >      - 状态转移：`dp[i][j] = dp[i][j-1]`。
  >
  >2. **匹配当前字符及之前的字符**（利用 `*` 的扩展性）：  
  >
  >      - 此时 `*` 匹配 `s` 的第 `i` 个字符，并可能继续匹配前面的字符。  
  >
  >      - 状态转移：`dp[i][j] = dp[i-1][j]`。
  >
  >---
  >
  >#### 3. 为什么 `dp[i-1][j]` 表示“匹配当前字符及之前的字符”？
  >
  >#### **数学归纳法的视角**
  >假设 `p[j] = '*'`，我们需证明：
  >- 若 `s[0...i-1]` 匹配 `p[0...j]`（即 `dp[i-1][j] = true`），则 `s[0...i]` 也能匹配 `p[0...j]`（即 `dp[i][j] = true`）。
  >
  >**解释**：
  >1. **`dp[i-1][j] = true` 的含义**：  
  >
  >      - `s` 的前 `i-1` 个字符已经被 `p` 的前 `j` 个字符匹配。  
  >
  >      - 由于 `p[j] = '*'`，`*` **已经覆盖了 `s` 的前 `i-1` 个字符**（可能是一个或多个字符）。
  >
  >2. **新增字符 `s[i]` 时**：  
  >
  >      - 当前字符 `s[i]` 可以被 `*` **继续匹配**（因为 `*` 可以匹配任意长度的字符串）。  
  >
  >      - 因此，`s` 的前 `i` 个字符仍然匹配 `p` 的前 `j` 个字符（即 `dp[i][j] = true`）。
  >
  >#### 具体例子分析
  >
  >假设 `s = "abc"`，`p = "a*"`：
  >1. **初始状态**：`dp[1][1] = true`（`s[0] = 'a'` 匹配 `p[0] = 'a'`）。
  >2. **处理 `p[1] = '*'`**：
  >  - 当 `i=2`（`s[1] = 'b'`），`j=2`：  
  >    - `dp[2][2] = dp[2][1] || dp[1][2]`。  
  >    - `dp[1][2] = true`（`s[0]` 已匹配 `p[0..1] = "a*"`）。  
  >    - **新增的 `s[1] = 'b'` 被 `*` 匹配**，所以 `dp[2][2] = true`。
  >  - 同理，`s[2] = 'c'` 也会被 `*` 匹配，`dp[3][2] = true`。
  >
  >---
  >
  >#### 4. 状态转移的直观理解
  >
  >- **`dp[i-1][j]` 的意义**：
  > 在 `p` 的第 `j` 个字符为 `*` 时，`dp[i-1][j] = true` 表示 `s` 的前 `i-1` 个字符已经被 `p` 的前 `j` 个字符匹配。
  >  此时，**新增的 `s[i]` 会被 `*` “吞并”**，而 `p` 的位置 `j` 无需移动（因为 `*` 可以匹配多个字符）。
  >
  >- **对比其他情况**：
  > 如果 `p[j]` 不是 `*`，则需要严格匹配 `s[i]` 和 `p[j]`，且 `dp[i][j]` 依赖 `dp[i-1][j-1]`。
  >  但 `*` 允许不消耗 `p` 的位置（通过 `dp[i-1][j]`），从而匹配多个字符。
  >
  >---
  >
  >#### 5. 数学形式化证明
  >
  >假设 `s` 和 `p` 的索引从 1 开始，且 `p[j] = '*'`，则：
  >- **若 `dp[i-1][j] = true`**：  
  >    - 存在一种匹配方式，使得 `s[1...i-1]` 匹配 `p[1...j]`。  
  >    - 由于 `p[j] = '*'`，可以扩展匹配范围，让 `s[1...i]` 也匹配 `p[1...j]`。  
  >    - 因此，`dp[i][j] = true`。
  >
  >- **反之**：  
  >    - 若 `dp[i][j] = true` 且 `p[j] = '*'`，则必须满足以下条件之一：  
  >        - `dp[i][j-1] = true`（`*` 不匹配任何字符），或  
  >        - `dp[i-1][j] = true`（`*` 匹配了 `s[i]`）。
  >
  >
  >---
  >
  >- **`dp[i-1][j]` 的本质**：
  > 利用 `*` 的贪婪匹配特性，将 `s` 的第 `i` 个字符“附加”到 `*` 已匹配的字符序列中。
  >  如果 `s` 的前 `i-1` 个字符已匹配 `p` 的前 `j` 个字符，则 `s` 的前 `i` 个字符也能匹配（通过 `*` 的扩展）。
  >
  >- **动态规划的巧妙性**：
  > 通过保留 `p` 的位置 `j`（即不移动 `p` 的指针），允许 `*` 匹配多个字符，避免了暴力枚举所有可能的分割点。
  
- **当 `p[j-1] ≠ '*'` 时**：  
  - 当前字符必须匹配：`p[j-1] == '?'` 或 `s[i-1] == p[j-1]`。  
  - 且前面的字符必须匹配：`dp[i-1][j-1] == true`。  
  - 综上：`dp[i][j] = (s[i-1] == p[j-1] || p[j-1] == '?') && dp[i-1][j-1]`。  

#### 3. 初始化  
- **空字符串匹配空模式**：`dp[0][0] = true`。  
- **处理模式 `p` 的前缀为 `*` 的情况**：  
  - 若 `p[0...j-1]` 全为 `*`，则 `dp[0][j] = true`。  
  - 一旦遇到非 `*` 字符，后续的 `dp[0][j]` 均为 `false`（因为 `*` 才能匹配空串）。

#### 4. 填表顺序  
- **按行填充**：外层循环遍历 `s` 的每个字符（`i` 从 1 到 `m`），内层循环遍历 `p` 的每个字符（`j` 从 1 到 `n`）。  
- 每个状态 `dp[i][j]` 依赖左方 `dp[i][j-1]`、左上方 `dp[i-1][j-1]` 或上方 `dp[i-1][j]`，按行填充可保证这些值已计算。

#### 5. 返回值  
- **最终结果**：`dp[m][n]`，即整个 `s` 和 `p` 是否完全匹配。

---

#### 示例解析

以 `s = "adceb"` 和 `p = "*a*b"` 为例：  
- **初始化**：`dp[0][0] = true`，`dp[0][1] = true`（`p[0] = '*'`），后续 `dp[0][j]` 为 `false`。  
- **填表过程**：  
  - `i=1`（`s[0] = 'a'`），`j=1`（`p[0] = '*'`）：`dp[1][1] = true`（`*` 匹配 `a`）。  
  - `j=2`（`p[1] = 'a'`）：`dp[1][2] = true`（`*a` 匹配 `a`）。  
  - 后续逐步填充，最终 `dp[5][4] = true`，匹配成功。  

#### 复杂度分析

- **时间复杂度**：O(m*n)，遍历整个 `dp` 数组。  
- **空间复杂度**：O(m*n)，存储二维状态表。
