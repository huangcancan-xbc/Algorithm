### 算法原理

#### 1. 状态表示

我们使用二维数组 `dp[i][j]`，其中：
- **i** 表示考虑字符串 `s` 的前 `i` 个字符（从 `s[0]` 到 `s[i-1]`）。
- **j** 表示考虑字符串 `t` 的前 `j` 个字符（从 `t[0]` 到 `t[j-1]`）。
- **`dp[i][j]` 的含义**：在 `s` 的前 `i` 个字符中，能找到多少个与 `t` 的前 `j` 个字符完全匹配的子序列。

例如，`dp[3][2]` 表示用 `s` 的前 3 个字符（如 `s[0], s[1], s[2]`），匹配 `t` 的前 2 个字符（`t[0], t[1]`）的子序列数目。

#### 2. 状态转移方程

根据 `s` 和 `t` 当前字符是否相等，分为两种情况：

##### 情况一：`s[i-1] == t[j-1]`（当前字符相等）

此时有两种选择：
1. **匹配当前字符**：用 `s[i-1]` 匹配 `t[j-1]`，此时子序列数量为 `dp[i-1][j-1]`（即前 `i-1` 和 `j-1` 的匹配数）。
2. **不匹配当前字符**：不用 `s[i-1]`，此时子序列数量为 `dp[i-1][j]`（即前 `i-1` 和 `j` 的匹配数）。

转移方程：
```c++
dp[i][j] = dp[i-1][j-1] + dp[i-1][j]
```

##### 情况二：`s[i-1] != t[j-1]`（当前字符不相等）
此时只能选择不匹配 `s[i-1]`，继承前 `i-1` 个字符的结果：
```c++
dp[i][j] = dp[i-1][j]
```

#### 3. 初始化

初始化是为了处理边界条件：
- **当 `j = 0`（`t` 为空字符串）**：任何 `s` 的前 `i` 个字符都可以通过删除所有字符得到一个空串，因此 `dp[i][0] = 1`。
- **当 `i = 0` 且 `j > 0`（`s` 为空但 `t` 非空）**：无法匹配，因此 `dp[0][j] = 0`。

代码中的初始化：
```cpp
for (int i = 0; i <= n; i++)
{
    dp[i][0] = 1;  // t为空时，只有一种方式
}
// 其余位置默认初始化为0
```

#### 4. 填表顺序

按 **从左到右、从上到下** 的顺序填充二维数组：
- **外层循环遍历 `i`**（从 1 到 `n`，对应 `s` 的每个字符）。
- **内层循环遍历 `j`**（从 1 到 `m`，对应 `t` 的每个字符）。

**原因**：计算 `dp[i][j]` 时，需要先知道 `dp[i-1][j-1]` 和 `dp[i-1][j]`，即上一行和左上方格子的值。因此，必须按顺序逐行填充。

#### 5. 返回值

最终结果为 `dp[n][m]`，表示用 `s` 的全部 `n` 个字符，匹配 `t` 的全部 `m` 个字符的子序列数目。

#### 举例说明

以 `s = "babg"`，`t = "ba"` 为例：
1. **初始化**：`dp[i][0] = 1`，`dp[0][j] = 0`（`j > 0`）。
2. **填表过程**：
   - `i=1`（`s[0] = 'b'`），`j=1`（`t[0] = 'b'`）：字符相等，`dp[1][1] = dp[0][0] + dp[0][1] = 1 + 0 = 1`。
   - `i=2`（`s[1] = 'a'`），`j=1`（`t[0] = 'b'`）：字符不等，`dp[2][1] = dp[1][1] = 1`。
   - `i=2`，`j=2`（`t[1] = 'a'`）：字符相等，`dp[2][2] = dp[1][1] + dp[1][2] = 1 + 0 = 1`。
   - 后续计算同理，最终 `dp[4][2] = 2`，即 `s` 中有两种方式得到 `t`（如 `s[0]+s[1]` 和 `s[0]+s[2]`）。
