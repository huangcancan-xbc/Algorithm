### 算法原理

#### 问题描述

给定两个字符串 `s1` 和 `s2`，通过删除字符使它们相等，求删除字符的 ASCII 值之和的最小值。
**关键观察**：删除的 ASCII 和最小 → 保留的公共子序列的 ASCII 和最大。

![image-20250303203134955](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250303203135139.png)

---

#### 1. 状态表示

定义二维数组 `dp[i][j]`（逆向思维）：  
- `dp[i][j]` 表示 `s1` 的前 `i` 个字符（`s1[0..i-1]`）和 `s2` 的前 `j` 个字符（`s2[0..j-1]`）内的所有的子序列里 **最大公共子序列的 ASCII 和**。  
- **最终目标**：保留的公共子序列的 ASCII 和最大 → 删除的 ASCII 和为 `总 ASCII 和 - 2 * dp[m][n]`。

#### 2. 状态转移方程

##### 情况一：`s1[i-1] == s2[j-1]`

- 当前字符是公共子序列的一部分，将其 ASCII 值加入结果。  
- **转移方程**：  
  
  ```cpp
  dp[i][j] = dp[i-1][j-1] + s1[i-1]
  ```

##### 情况二：`s1[i-1] != s2[j-1]`

- 当前字符不匹配，选择保留 `s1` 或 `s2` 的字符中更优的方案。  
- **转移方程**：  
  ```cpp
  dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```

>### 详细状态转移方程推导过程
>
>在求最小 ASCII 删除和时，我们需要找到两个字符串的 **最大公共子序列（LCS）的 ASCII 和**。状态转移方程需覆盖所有可能的选择，但某些情况可以通过合并优化。
>
>这里的 **“有” 和 “没有”** 指的是 **是否保留当前字符** 到公共子序列中。对于位置 `i`（`s1` 的第 `i` 个字符）和 `j`（`s2` 的第 `j` 个字符），存在四种选择：
>
>1. **情况一**：有 `s1(i)`，有 `s2(j)`（保留 `s1[i]` **且** 保留 `s2[j]`） → 必须满足 `s1[i] == s2[j]`。
>2. **情况二**：有 `s1(i)`，没有 `s2(j)`（保留 `s1[i]` **但** 不保留 `s2[j]`）。
>3. **情况三**：没有 `s1(i)`，有 `s2(j)`（不保留 `s1[i]` **但** 保留 `s2[j]`）。
>4. **情况四**：没有 `s1(i)`，没有 `s2(j)`（不保留 `s1[i]` **且** 不保留 `s2[j]`）。
>
>---
>
>#### 各情况的正确性分析
>
>##### **情况一：保留 `s1[i]` 且保留 `s2[j]`（正确）**
>
>- **条件**：`s1[i] == s2[j]`。
>- **操作**：将当前字符加入公共子序列，累加其 ASCII 值。
>- **代码对应**：  
>  ```cpp
>  if (s1[i-1] == s2[j-1])
>  {
>      dp[i][j] = max(dp[i][j], dp[i-1][j-1] + s1[i-1]);
>  }
>  ```
>- **正确性**：当字符相等时，必须保留它们以获得更大的 ASCII 和。这是最优解的必要条件。
>
>##### 情况二：保留 `s1[i]` 但丢弃 `s2[j]`（正确）
>
>- **条件**：`s1[i] != s2[j]`。
>- **操作**：丢弃 `s2[j]`，保留 `s1[i]` 并继承之前的状态。
>- **代码对应**：  
>  ```cpp
>  dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // 取左或上方的最大值
>  ```
>  - 若选择 `dp[i][j-1]`，表示保留 `s1[i]` 但丢弃 `s2[j]`。
>- **正确性**：通过 `max` 操作隐式选择保留 `s1` 或 `s2` 的更优解，确保不丢失可能的更大公共子序列。
>
>##### 情况三：丢弃 `s1[i]` 但保留 `s2[j]`（正确）
>
>- **条件**：`s1[i] != s2[j]`。
>- **操作**：丢弃 `s1[i]`，保留 `s2[j]` 并继承之前的状态。
>- **代码对应**：  
>  
>  ```cpp
>  dp[i][j] = max(dp[i-1][j], dp[i][j-1]);  // 取左或上方的最大值
>  ```
>  - 若选择 `dp[i-1][j]`，表示保留 `s2[j]` 但丢弃 `s1[i]`。
>- **正确性**：同情况二，通过 `max` 操作隐式处理，确保选择最优路径。
>
>##### 情况四：同时丢弃 `s1[i]` 和 `s2[j]`（错误）
>
>- **条件**：`s1[i] != s2[j]`。
>- **操作**：同时丢弃两个字符，继承 `dp[i-1][j-1]`。
>- **代码对应**：**无显式处理**，因为代码中未直接使用 `dp[i-1][j-1]`。
>- **错误原因**：  
>  
>  - 同时丢弃两个字符的方案 **一定不是最优解**。  
>  - 例如：若保留 `s1[i]` 或 `s2[j]` 中至少一个，可能得到更大的公共子序列 ASCII 和。  
>  - **数学证明**：
>    假设存在最优解需要同时丢弃 `s1[i]` 和 `s2[j]`，则此时最大公共子序列的 ASCII 和为 `dp[i-1][j-1]`。但根据状态转移方程：  
>    
>    ```cpp
>    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) ≥ dp[i-1][j-1]
>    ```
>    因此，选择保留至少一个字符的方案一定优于同时丢弃两个字符的方案。
>
>---
>
>- **情况一**：必须显式处理，直接累加匹配字符的 ASCII 值。  
>- **情况二/三**：通过 `max` 操作隐式合并，选择保留 `s1` 或 `s2` 的更优解。  
>- **情况四**：被排除，因为同时丢弃两个字符的方案不可能是最优解。  
>
>**动态规划的核心思想**：通过状态转移保留所有可能的最优子结构，避免无效计算。代码中通过 `max` 操作巧妙地合并了情况二和情况三，同时排除了情况四，确保算法的高效性。

#### 3. 初始化

- **空字符串的公共子序列为 0**：  
  
  ```cpp
  dp[0][j] = 0, dp[i][0] = 0
  ```

#### 4. 填表顺序

- **按行填充**：外层循环遍历 `s1` 的每个字符（`i` 从 1 到 `m`），内层循环遍历 `s2` 的每个字符（`j` 从 1 到 `n`）。  
- **依赖关系**：  
  - `dp[i][j]` 依赖左方 `dp[i][j-1]`、上方 `dp[i-1][j]` 和左上方 `dp[i-1][j-1]`。

#### 5. 返回值

- **总 ASCII 和减去两倍的最大公共子序列 ASCII 和**：  
  ```cpp
  sum(s1) + sum(s2) - 2 * dp[m][n]
  ```

---

#### 实例解析

以 `s1 = "sea"`，`s2 = "eat"` 为例：  
1. **初始化**：`dp[0][j] = 0`，`dp[i][0] = 0`。  
2. **填表过程**：  
   - `i=1`（`s1[0] = 's'`），`j=1`（`s2[0] = 'e'`）：不匹配，取 `max(0, 0) = 0`。  
   - `i=2`（`s1[1] = 'e'`），`j=1`（`s2[0] = 'e'`）：匹配，`dp[2][1] = 0 + 'e' = 101`。  
   - 最终 `dp[3][3] = 231`（公共子序列为 `"ea"`，ASCII 和为 `101 + 97 = 198`）。  
3. **结果**：`sum(s1) + sum(s2) - 2 * 198 = 231 + 314 - 396 = 149`。
