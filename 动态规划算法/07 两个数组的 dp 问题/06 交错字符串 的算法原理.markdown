### 算法原理

**问题描述**：给定三个字符串 `s1`、`s2`、`s3`，判断 `s3` 是否由 `s1` 和 `s2` 的交错组合形成。
**交错组合** 的定义：保持 `s1` 和 `s2` 的字符顺序不变，交替选取字符组成 `s3`。

![image-20250303191015352](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250303191015562.png)

---

#### 1. 状态表示

定义二维数组 `dp[i][j]`：  
- `dp[i][j]` 表示 `s1` 的前 `i` 个字符和 `s2` 的前 `j` 个字符是否可以交错形成 `s3` 的前 `i+j` 个字符。  
- **索引处理**：代码中在 `s1`、`s2`、`s3` 前添加了一个空格（`s1[0] = s2[0] = s3[0] = ' '`），使得索引从 1 开始，避免处理负数下标。

#### 2. 状态转移方程

对于 `dp[i][j]`，分两种情况：  
- **当前字符来自 `s1`（`s3` 的末尾是 `s1` 最后 `i` 位置上的字符）**：  
  - `s1[i]` 必须等于 `s3[i+j]`。  
  - 且前 `i-1` 个字符和 `s2` 的前 `j` 个字符能形成 `s3` 的前 `i+j-1` 个字符，即 `dp[i-1][j] = true`。  

- **当前字符来自 `s2`（`s3` 的末尾是 `s2` 最后 `j` 位置上的字符）**：  
  - `s2[j]` 必须等于 `s3[i+j]`。  
  - 且前 `i` 个字符和 `s2` 的前 `j-1` 个字符能形成 `s3` 的前 `i+j-1` 个字符，即 `dp[i][j-1] = true`。  

**转移方程**：  
```cpp
dp[i][j] = (s1[i] == s3[i+j] && dp[i-1][j]) || (s2[j] == s3[i+j] && dp[i][j-1]);
```

#### 3. 初始化详解

初始化处理的是边界情况：当 `s1` 或 `s2` 为空时，`s3` 必须完全由另一个字符串按顺序组成。

##### **第一行初始化（`s1` 为空）**  
- `s3` 的前 `j` 个字符必须完全由 `s2` 的前 `j` 个字符按顺序组成。  
- **判断逻辑**：  
  1. 遍历 `j` 从 1 到 `n`（`s2` 的长度）。  
  2. 若 `s2[j] == s3[j]`，则 `dp[0][j] = dp[0][j-1]`（继承前一状态）。  
  3. 若某个位置不匹配，后续所有 `j` 都无法匹配，直接 `break`，后续默认都是 `false`。

**示例**：  

- `s1 = ""`，`s2 = "abc"`, `s3 = "abd"`：  
  - `j=1`：`s2[1] = 'a'`，`s3[1] = 'a'` → `dp[0][1] = dp[0][0] = true`。  
  - `j=2`：`s2[2] = 'b'`，`s3[2] = 'b'` → `dp[0][2] = dp[0][1] = true`。  
  - `j=3`：`s2[3] = 'c'`，`s3[3] = 'd'` → 不匹配，后续 `j>3` 的 `dp[0][j]` 均为 `false`。

##### **第一列初始化（`s2` 为空）**  
- 逻辑与第一行对称：`s3` 的前 `i` 个字符必须完全由 `s1` 的前 `i` 个字符按顺序组成。  
- **判断逻辑**：  
  1. 遍历 `i` 从 1 到 `m`（`s1` 的长度）。  
  2. 若 `s1[i] == s3[i]`，则 `dp[i][0] = dp[i-1][0]`（继承前一状态）。  
  3. 若某个位置不匹配，后续所有 `i` 都无法匹配，直接 `break`，后续默认都是 `false`。

**示例**：  
- `s1 = "abc"`, `s2 = “”` `s3 = "abx"`：  
  - `i=1`：`s1[1] = 'a'`，`s3[1] = 'a'` → `dp[1][0] = dp[0][0] = true`。  
  - `i=2`：`s1[2] = 'b'`，`s3[2] = 'b'` → `dp[2][0] = dp[1][0] = true`。  
  - `i=3`：`s1[3] = 'c'`，`s3[3] = 'x'` → 不匹配，后续 `i>3` 的 `dp[i][0]` 均为 `false`。

#### 4. 填表顺序

- **按行填充**：外层循环遍历 `s1` 的每个字符（`i` 从 1 到 `m`），内层循环遍历 `s2` 的每个字符（`j` 从 1 到 `n`）。  
- **依赖关系**：  
  - `dp[i][j]` 依赖上方 `dp[i-1][j]` 和左方 `dp[i][j-1]`，按行填充确保这些状态已计算。

#### 5. 返回值

- **最终结果**：`dp[m][n]`，表示整个 `s1` 和 `s2` 是否能交错形成 `s3`。

---

#### 实例解析

以 `s1 = "aab"`, `s2 = "dbb"`, `s3 = "adabb"` 为例：  
1. **初始化**：  
   - `s3` 长度为 5，`s1` 长度 3 + `s2` 长度 3 = 6 → 长度不匹配，直接返回 `false`。  

以 `s1 = "aab"`, `s2 = "dbb"`, `s3 = "aadbbb"` 为例：  
1. **初始化**：  
   - `s3` 长度 6，`s1` 长度 3 + `s2` 长度 3 = 6 → 长度匹配。  
   - 处理第一行（`s1` 为空）：`s2 = "dbb"`, `s3 = "aadbbb"` → 第一行无法匹配，`dp[0][j]` 全为 `false`。  
   - 处理第一列（`s2` 为空）：`s1 = "aab"`, `s3 = "aadbbb"` → 前 3 个字符 `"aab"` 匹配 `s3` 的前 3 个字符 `"aaa"`？不匹配，`dp[i][0]` 全为 `false`。  

2. **填表过程**：  
   - `i=1`, `j=1`：`s3[2] = 'a'` 需匹配 `s1[1] = 'a'` 或 `s2[1] = 'd'` → 只能来自 `s1`，检查 `dp[0][1] = false` → `dp[1][1] = false`。  
   - 最终 `dp[3][3] = false`，无法匹配。

#### 关键点总结

- **初始化的重要性**：处理 `s1` 或 `s2` 为空的情况，确保 `s3` 必须完全由另一个字符串按顺序组成。  
- **状态转移逻辑**：当前字符必须来自 `s1` 或 `s2`，且前面的子问题必须已解决。  
- **提前终止优化**：初始化中遇到不匹配字符立即终止，减少不必要的计算。
