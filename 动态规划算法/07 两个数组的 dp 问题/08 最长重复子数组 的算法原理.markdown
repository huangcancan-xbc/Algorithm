### 算法原理详解

#### 问题描述

给定两个整数数组 `nums1` 和 `nums2`，返回两个数组中 **公共的、长度最长的子数组（连续）** 的长度。

-   **子数组**：必须连续，例如 `[1,2,3]` 的子数组可以是 `[1,2]` 或 `[2,3]`，但不能是 `[1,3]`。
-   **子序列**：可以不连续，例如 `[1,2,3]` 的子序列可以是 `[1,3]`。

![image-20250303211106869](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250303211106990.png)

### 为什么不能使用子序列的动态规划方法？

#### 子序列与子数组的核心区别

1. **连续性要求**：  
   
   - 子数组必须连续，子序列可以不连续。  
   - 例如：`nums1 = [1,2,3,4]`，`nums2 = [1,3,4]`  
     - 公共子数组：`[1]` 或 `[3,4]`（最长长度为 2）。  
     - 公共子序列：`[1,3,4]`（长度为 3）。  
   
2. **状态转移的差异**：  
   - **子序列**（如 LCS 问题）：  
     - `dp[i][j]` 表示 `nums1[0..i-1]` 和 `nums2[0..j-1]` 的最长公共子序列长度。  
     - 转移方程：  
       ```cpp
       if (nums1[i-1] == nums2[j-1])
       {
           dp[i][j] = dp[i-1][j-1] + 1;
       }
       else
       {
           dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
       }
       ```
   - **子数组**：  
     - 由于连续性要求，公共子数组必须从某个起点开始连续匹配，因此 `dp[i][j]` **必须表示以 `nums1[i-1]` 和 `nums2[j-1]` 结尾的最长公共子数组长度**。  
     - 转移方程：  
       ```cpp
       if (nums1[i-1] == nums2[j-1])
       {
           dp[i][j] = dp[i-1][j-1] + 1;
       }
       else
       {
           dp[i][j] = 0;  // 不连续则直接断开
       }
       ```

### 为什么状态表示必须定义为“以 i 和 j 结尾的子数组”？

假设尝试用子序列的状态定义方法：  
- 定义 `dp[i][j]` 为 `nums1[0..i-1]` 和 `nums2[0..j-1]` 的最长公共子数组长度。  
- 此时，若 `nums1[i-1] != nums2[j-1]`，无法直接确定如何转移状态：  
  - 如果当前字符不匹配，最长公共子数组可能出现在 `nums1[0..i-2]` 和 `nums2[0..j-1]` 或 `nums1[0..i-1]` 和 `nums2[0..j-2]` 中。  
  - 但这样做会导致状态转移无法保证连续性，最终结果可能包含不连续的子数组。  

**反例**：  
- `nums1 = [1,2,3,4]`，`nums2 = [1,3,4]`  
- 若允许非连续匹配，`dp[4][3]` 会错误地记录长度为 3（对应子序列 `[1,3,4]`），但实际最长公共子数组的长度是 2（`[3,4]`）。

---

### 正确的动态规划设计

#### 1. 状态表示

- `dp[i][j]`：以 `nums1[i-1]` 和 `nums2[j-1]` **结尾的公共子数组的长度**。  
- **为什么索引是 `i-1` 和 `j-1`？**
  为了方便处理边界条件，代码中将 `nums1` 和 `nums2` 的索引从 1 开始（即 `dp[1][1]` 对应 `nums1[0]` 和 `nums2[0]`）。

#### 2. 状态转移方程

- **若 `nums1[i-1] == nums2[j-1]`**：  
  - 当前字符可以扩展前面的公共子数组，长度加 1。  
  - `dp[i][j] = dp[i-1][j-1] + 1`。  

- **若 `nums1[i-1] != nums2[j-1]`**：  
  - 无法形成以当前字符结尾的公共子数组，长度重置为 0。  
  - `dp[i][j] = 0`。

#### 3. 初始化

- `dp[0][j] = 0` 和 `dp[i][0] = 0`：空字符串与任何字符串的公共子数组长度为 0。  

#### 4. 填表顺序

- 按行遍历 `i` 从 1 到 `m`，内层遍历 `j` 从 1 到 `n`。  
- **依赖关系**：`dp[i][j]` 仅依赖左上方 `dp[i-1][j-1]`。

#### 5. 返回值

- 遍历过程中维护全局最大值 `ret`，最终返回 `ret`。
