### 算法原理

#### 1. **状态定义**

**`dp[i][j]`** 表示 `text1` 的前 `i` 个字符（即索引 `0` 到 `i-1`）和 `text2` 的前 `j` 个字符（即索引 `0` 到 `j-1`）的最长公共子序列的长度。

- **边界条件**：当 `i=0` 或 `j=0` 时，`dp[i][j] = 0`（空字符串无公共子序列）。

#### 2. **状态转移方程**

![image-20250226225048498](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250226225048584.png)

根据字符是否相等，分两种情况：  
- **字符相等**（`text1[i-1] == text2[j-1]`）—— 结论：如果两个字符串 `text1` 和 `text2` 分别以 `i` 和 `j` 位置为结尾，且这两个位置的字符相同（即 `text1[i-1] == text2[j-1]`），那么它们的最长公共子序列的长度一定为：
  
  ```  
  dp[i][j] = dp[i-1][j-1] + 1  
  ```
  解释：
  
  -   **字符相同**：如果 `text1[i-1]` 和 `text2[j-1]` 相同，那么这两个字符一定可以加入 最长公共子序列 中。
  -   **递推关系**：
      
      -   `dp[i-1][j-1]` 表示 `text1` 的前 `i-1` 个字符和 `text2` 的前 `j-1` 个字符的 最长公共子序列 长度。
      -   因为 `text1[i-1]` 和 `text2[j-1]` 相同，所以它们可以追加到 `dp[i-1][j-1]` 对应的 最长公共子序列 中，形成一个新的 最长公共子序列，长度为 `dp[i-1][j-1] + 1`。
      
  -   **反证法验证**：
  
      假设 `dp[i][j]` 不等于 `dp[i-1][j-1] + 1`，即存在一个更长的 最长公共子序列 不包含 `text1[i-1]` 和 `text2[j-1]`。
  
      -   这与 `text1[i-1] == text2[j-1]` 矛盾，因为这两个字符相同，一定可以加入 最长公共子序列 中，使 最长公共子序列 长度增加 1。
      -   因此，结论成立。
- **字符不等**（`text1[i-1] != text2[j-1]`）：  
  
  ```  
  dp[i][j] = max(dp[i-1][j], dp[i][j-1])  
  ```
  解释：最后的字符不相同，就往前找……

#### 3. **初始化**

- `dp[0][j] = 0`（`text1` 为空），`dp[i][0] = 0`（`text2` 为空）。  
- 代码中通过 `vector` 默认初始化为 0 实现。

#### 4. **填表顺序**

-   从上到下，从左到右

- **外层循环** 遍历 `i`（从 1 到 `n`），**内层循环** 遍历 `j`（从 1 到 `m`）。  
- 保证在计算 `dp[i][j]` 时，其依赖的 `dp[i-1][j-1]`、`dp[i-1][j]`、`dp[i][j-1]` 均已计算。

#### 5. **返回值**

- `dp[n][m]` 即为两个字符串的最长公共子序列长度。

#### 复杂度

- **时间复杂度**：O(n·m)，需遍历二维表。  
- **空间复杂度**：O(n·m)，存储 `dp` 表。  
- **优化方向**：使用滚动数组可将空间复杂度降至 O(min(n, m))。
