### 算法原理

#### 1. **问题转化**  
题目要求在两个数组之间画不相交的线，等价于在两个数组中找到最长的公共子序列（LCS）。
**原因**：  

- 若 `nums1[i] = nums2[j]`，可以画一条线且不与其他线交叉，当且仅当这些元素在两个数组中的顺序一致。  
- 最长公共子序列的每个元素按顺序对应一组不相交的线。

#### 2. **状态定义**

**`dp[i][j]`** 表示 `nums1` 前 `i` 个元素与 `nums2` 前 `j` 个元素能形成的最多不相交线数（即 LCS 长度）。  
- **边界条件**：当 `i=0` 或 `j=0` 时，`dp[i][j] = 0`（空数组无线可画）。

#### 3. **状态转移方程**

![image-20250226235502182](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250226235502295.png)

根据元素是否相等，分两种情况：  
- **元素相等**（`nums1[i-1] == nums2[j-1]`）：  
  ```  
  dp[i][j] = dp[i-1][j-1] + 1  
  ```
  解释：当前元素匹配，线数比前序状态多 1。  
- **元素不等**（`nums1[i-1] != nums2[j-1]`）：  
  ```  
  dp[i][j] = max(dp[i-1][j], dp[i][j-1])  
  ```
  解释：舍弃 `nums1` 的当前元素或 `nums2` 的当前元素，保留最大线数。

#### 4. **填表顺序**  
- **外层循环** 遍历 `i`（从 1 到 `n`），**内层循环** 遍历 `j`（从 1 到 `m`）。  
- 确保计算 `dp[i][j]` 时，其依赖的 `dp[i-1][j-1]`、`dp[i-1][j]`、`dp[i][j-1]` 已计算。

#### 5. **返回值**

- `dp[n][m]` 即为两个数组的最长公共子序列长度，即最大不相交线数。

#### 复杂度

- **时间复杂度**：O(n·m)，需遍历二维表。  
- **空间复杂度**：O(n·m)，存储 `dp` 表。
