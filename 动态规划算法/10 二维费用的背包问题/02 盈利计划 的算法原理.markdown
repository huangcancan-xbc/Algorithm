### 算法原理

**问题描述**：给定 `n` 名成员和若干任务，每个任务需要 `group[i]` 名成员并产生 `profit[i]` 的利润。求在**成员总数不超过 `n`** 的前提下，**总利润至少为 `minProfit`** 的任务组合数（结果对 `1e9 + 7` 取模）。

这道题目非常难读懂，但是如果结合例子多读几遍，你就会发现是一个经典的「二维费用的背包问题」。因此我们可以仿照「二维费用的背包」来定义状态表示。

![image-20250305220844416](https://cdn.jsdelivr.net/gh/huangcancan-xbc/Drawing-bed@master/Algorithm/20250305220844563.png)

---

#### 1. 状态表示

-   `dp[i][j][k]` 表示：从前 `i` 个计划中挑选，总人数不超过 `j`，总利润至少为 `k`，一共有多少种选法。
-   **核心思想**：通过动态规划统计所有可能的合法组合，结合“选择当前任务”和“不选择当前任务”两种情况。

注意，这道题目里面出现了一个「至少」，和之前做过的背包问题不一样。因此，我们在分析「状态转移方程」的时候要结合实际情况考虑一下。

#### 2. 状态转移方程

根据「最后一个位置」的元素，结合题目的要求，我们有「选择」最后一个元素或者「不选择」最后一个元素两种策略：
- **不选 `i` 位置的计划**：那我们只能去前 `i - 1` 个计划中挑选，总人数不超过 `j`，总利润至少为 `k`。此时一共有 `dp[i - 1][j][k]` 种选法；
- **选择 `i` 位置的计划**：那我们在前 `i - 1` 个计划中挑选的时候，限制就变成了，总人数不超过 `j - g[i]`，总利润至少为 `k - p[i]`。此时一共有 `dp[i - 1][j - g[i]][max(0, k - p[i])]` 种选法。

第二种情况有两个细节需要注意：
1. 如果 `j - g[i] < 0`，此时说明 `g[i]` 过大，也就是人数过多。因为我们的状态表示要求人数是不能超过 `j` 的，因此这个状态是不合法的，需要舍去。
2. 如果 `k - p[i] < 0`，此时说明 `p[i]` 过大，也就是利润太高。但是利润高，正是我们想要的，所以这个状态「不能舍去」。然而，我们的 dp 表是没有负数的下标的，这意味着这些状态我们无法表示。实际上，如果这个任务的利润已经能够达标了，我们仅需在之前的任务中，挑出来的利润至少为 0 就可以了。因此这种情况等价于 `dp[i][j][0]`，我们可以对 `k - p[i]` 的结果与 0 取一个 `max`。

综上，我们的状态转移方程为：
```
dp[i][j][k] = dp[i - 1][j][k] + dp[i - 1][j - g[i - 1]][max(0, k - p[i - 1])]
```

#### 3. 初始化
- **初始条件**：当没有任务可选时（`i = 0`）：
    - `dp[0][j][0] = 1`（`j` 为任意值）：表示不选任何任务时，使用 0 名成员（满足 `j >= 0`），总利润为 0（满足 `k >= 0`），存在 1 种方案（此时无论人数限制为多少，我们都能找到一个「空集」的方案。因此初始化 `dp[0][j][0]` 的位置为 1，其中 `0 <= j <= n`）。
    - 其他 `dp[0][j][k > 0] = 0`：没有任务时无法产生正利润。
- **意义**：初始化确保后续状态转移的基础正确性。

#### 4. 填表顺序
根据「状态转移方程」，我们保证 `i` 从小到大即可。

- **外层遍历任务**：从第 1 个任务到第 `len` 个任务。
- **中层遍历成员数**：从 0 到 `n`。
- **内层遍历利润**：从 0 到 `minProfit`。

#### 5. 返回值

根据「状态表示」，我们返回 `dp[len][m][n]`。其中 `len` 表示字符串数组的长度。

#### 6. 空间优化

所有的「背包问题」，都可以进行空间上的优化。对于「二维费用的 01 背包」类型的，我们的优化策略是：
- 删掉第一维；
- 修改第二层以及第三层循环的遍历顺序（从大到小）即可，以确保每个物品只被选择一次。这样可以在不增加额外空间复杂度的情况下，减少空间使用量。